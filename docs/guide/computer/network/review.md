# 网络复习

## HTTP 的基本概念

HTTP 是互联网上应用最为广泛的一种网络协议。它是一个客户端和服务器端请求和应答的协议，基于 TCP/IP 进行通信。HTTP 主要用于从 WWW 服务器传输超文本到本地浏览器，故称为“超文本传输协议”。

## HTTP工作原理

HTTP协议定义了 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何将 Web 页面传送给客户端。HTTP 通信开始时，客户端向服务器发送一个请求报文，服务器则以一个响应报文进行回复。

## HTTP请求/响应的步骤

1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放TCP连接
5. 客户端（浏览器）解析HTML内容

> 记忆口诀：连接、发送、响应三步走，释放后解析不放过。

## HTTP 的 5 种方法

- **GET** - 获取资源
- **POST** - 传输资源
- **PUT** - 更新资源
- **DELETE** - 删除资源
- **HEAD** - 获取报文首部

## GET与POST的区别

1. **浏览器回退表现不同**：GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
2. **浏览器对请求地址的处理不同**：GET 请求的地址会被浏览器主动缓存，而 POST 不会，除非手动设置。
3. **浏览器对响应的处理不同**：GET 请求的参数会被完整地保留在浏览器的历史记录里，而 POST 的参数不会被保留。
4. **参数大小不同**：GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
5. **安全性不同**：GET 参数通过 URL 传递，可能会被暴露，相对不安全；而 POST 参数存放在 Request Body 中，相对更安全。
6. **针对数据操作的类型不同**：GET 主要用于查询数据，而 POST 用于添加、修改或删除数据。简言之，GET 是只读的，而 POST 是用于写操作的。

## HTTP报文的组成成分

HTTP 报文主要由请求报文和响应报文组成。其中，

- **请求报文** 包括：请求行、请求头、空行、请求体
  - 请求行由以下组成：HTTP方法、URL、HTTP版本
- **响应报文** 包括：状态行、响应头、空行、响应体

**Request Header 示例:**

```markdown
1. GET /sample.Jsp HTTP/1.1  // 请求行
2. Host: www.uuid.online  // 请求的目标域名
3. Origin: http://localhost:8081  // 请求的来源域名和端口号
4. Referer: https://localhost:8081/link?query=xxxxx  // 请求资源的完整URI
5. User-Agent: Mozilla/5.0 ... Safari/537.36  // 浏览器信息
6. Cookie: BAIDUID=FA89F036:... sugstore=0  // 当前域名下的Cookie
7. Accept: text/html,image/apng  // 希望接受的数据类型
8. Accept-Encoding: gzip, deflate  // 支持的压缩格式
9. Accept-Language: zh-CN,zh;q=0.9  // 支持的语言
10. Connection: keep-alive  // TCP连接控制
```

**Response Header 示例:**

```markdown
1. HTTP/1.1 200 OK  // 响应状态行
... [其他响应头信息，与上文类似]
```

## HTTPS 的基本概念

HTTPS 是 HTTP 下加入 SSL/TLS 层进行加密的协议，它旨在提供安全的 HTTP 通道。

HTTPS 协议的主要作用是：

- 建立一个信息安全的通道，确保数据的加密传输。
- 通过证书验证服务器的真实性，防止中间人攻击。

## HTTP 和 HTTPS 的区别？

- HTTP 是明文传输的超文本传输协议，而 HTTPS 是具有安全性的 SSL/TLS 加密传输协议。
- HTTPS 需要使用 CA 证书，而这通常是有成本的。
- HTTP 和 HTTPS 使用不同的端口，通常 HTTP 使用 80，而 HTTPS 使用 443。
- HTTP 的连接是无状态的，而 HTTPS 的连接除了是有状态的，还是加密的。

> 记忆口诀：明文传输与超文本，安全等级各有差异。CA 证书需付费，HTTP 无状态、HTTPS 加密传。

## HTTPS 协议的工作原理

![HTTPS 工作原理](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42bc6f45451457fa6d614fb27534516~tplv-k3u1fbpfcp-watermark.image?)

HTTPS 在与 Web 服务器通信时的步骤如下：

1. 客户端通过 HTTPS URL 请求服务器，要求建立 SSL/TLS 链接。
2. 服务器将其证书（含公钥）发送给客户端。
3. 客户端与服务器协商确定加密算法和密钥。
4. 客户端使用公钥加密一个随机的会话密钥，并发送给服务器。
5. 服务器使用私钥解密得到会话密钥。
6. 双方使用会话密钥进行加密通信。

> 记忆口诀：HTTPS 连接步骤六，密钥交换安全必。

## HTTPS 协议的优缺点

- HTTPS 比 HTTP 更加**安全**，能够保护数据在传输过程中不被窃取或篡改，确保数据完整性。
- HTTPS 握手阶段相对耗时，可能会导致页面加载时间增加约50%，并可能导致增加10%~20%的电量消耗。
- HTTPS 的**缓存效率**低于 HTTP，可能增加数据传输的开销。
- SSL 证书需要购买，功能更强大的证书通常费用更高。
- SSL 证书需要与 IP 地址绑定，这意味着不能在同一个 IP 地址上绑定多个域名，这种做法受到IPv4资源的限制。

## TCP/IP 网络模型

TCP/IP模型是互联网的核心，由一系列网络协议组成。这些协议可以分为四层：链路层、网络层、传输层和应用层。

- **链路层**：负责封装和解封装 IP 报文，以及发送和接收 ARP/RARP 报文等。
- **网络层**：负责选择最优的路由路径，将分组报文发送到目标网络或主机。
- **传输层**：对报文进行分段和重组，并根据 TCP 或 UDP 协议格式进行封装。
- **应用层**：提供各种应用程序接口，如 HTTP、FTP、Telnet、DNS、SMTP 等。

## TCP 三次握手

1. 第一次握手：客户端发送 SYN 包 (SYN=j) 到服务器，并转换到 SYN_SENT 状态，等待服务器确认。
2. 第二次握手：服务器接收到 SYN 包后确认客户端的 SYN（ACK=j+1），同时发送自己的 SYN 包（SYN=k），即发送 SYN+ACK 包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的 SYN+ACK 包后，发送确认包 ACK(ACK=k+1)，完成后，双方进入 ESTABLISHED 状态，完成三次握手。

> 握手过程中传送的包不包含数据内容。只有在三次握手完毕后，客户端和服务器才开始正式传输数据。

## TCP 四次挥手

1. 客户端发出连接释放报文，停止发送数据。此释放报文头部设置 FIN=1，序列号为 seq=u，随后客户端进入 FIN-WAIT-1 状态。
2. 服务器收到释放报文后，发出确认报文，进入 CLOSE-WAIT 状态。
3. 客户端收到服务器的确认后，进入 FIN-WAIT-2 状态，等待服务器的释放报文。
4. 服务器发送最后的数据和连接释放报文，随后进入 LAST-ACK 状态。
5. 客户端收到服务器的释放报文后，发送确认，然后进入 TIME-WAIT 状态。经过一段时间后，客户端进入 CLOSED 状态。
6. 服务器收到客户端的确认后，立即进入 CLOSED 状态。

## TCP 和 UDP 的区别

1. TCP 是面向连接的，而 UDP 是无连接的。
2. TCP 仅支持单播传输，而 UDP 支持单播、多播和广播。
3. TCP 通过三次握手保证了连接的可靠性。而 UDP 是无连接且不可靠的，没有建立连接的步骤，发送端不确保数据的正确接收。
4. UDP 的头部开销小于 TCP，数据传输速率更快，更适合于要求实时性的应用。

## HTTP 请求跨域问题

1. **跨域的原理**

    **跨域** 是指由于浏览器的`同源策略`限制，一个域的文档或脚本试图去请求另一个域的资源。\
    **同源策略** 是一种约定，它是浏览器对 JavaScript 实施的安全限制。只要`协议`、`域名`、或`端口`有任何一个不同，那么两个域就被认为是不同的域。\
    **跨域原理** 是指通过某种方式绕过这些安全限制，使得不同的域之间可以互相请求资源。

2. **解决方案**

    - **JSONP**：\
      利用`<script>`标签的src属性可以访问跨域的 js 脚本的特性，服务器返回一个调用某个函数的 js 代码，客户端再通过此函数接收数据。

        ```js
        var script = document.createElement('script');
        function getData(data) {
            console.log(data);
        }
        script.src = 'http://localhost:3000/?callback=getData';
        document.body.appendChild(script);
        ```

      **缺点**：\
      只支持 GET 请求；需要后端配合返回指定格式的数据。

    - **document.domain**：\
      适用于子域名不同，但基础域名相同的情况。

    - **window.name**：\
      所有窗口内的域名都共享同一个 window.name。

    - **CORS**：\
      服务器设置`Access-Control-Allow-Origin` HTTP响应头，浏览器会允许跨域请求。

    - **proxy代理**：\
      利用服务器端进行转发请求，从而绕过浏览器的同源策略。

    - **window.postMessage()**：\
      利用 HTML5 的 postMessage 方法进行跨域通信。

    - **Websocket**：\
      允许进行全双工通信的网络协议，可以进行跨域通信。

## Cookie、sessionStorage、localStorage 的区别

**相同点**：

- 都是存储在客户端的技术。

**不同点**：

- **存储大小**：
  - cookie 数据大小不能超过4K。
  - sessionStorage 和 localStorage 可以存储约5M的数据。

- **生命周期**：
  - cookie 根据设置的过期时间持续有效。
  - localStorage 数据持久保存，即使浏览器关闭也不会丢失，除非用户主动删除数据。
  - sessionStorage 数据在当前浏览器窗口或标签页关闭后自动删除。

- **与服务器交互**：
  - cookie 数据在每次向服务器发送请求时都会被自动附带，无论是否需要。
  - sessionStorage 和 localStorage 数据只保存在本地，不会被自动发送到服务器。

以下是对文档的修复和补充：

## HTTP状态码及常见状态码

### HTTP状态码

- **1xx：指示信息类** - 表示请求已接受，继续处理。
- **2xx：指示成功类** - 表示请求已成功被服务器接收、理解并接受。
- **3xx：指示重定向** - 表示要完成请求必须进行进一步的操作。
- **4xx：指示客户端错误** - 请求包含错误的语法或不能完成。
- **5xx：指示服务器错误** - 服务器在处理请求时出错。

### 常见状态码

- **200 OK**：客户端请求成功。
- **301 Moved Permanently**：所请求的页面已永久重定向至新的URL。
- **302 Found**：所请求的页面已临时重定向至新的URL。
- **304 Not Modified**：资源自上次请求后未发生变化。
- **403 Forbidden**：服务器拒绝了客户端的请求。
- **404 Not Found**：服务器找不到请求的资源。
- **500 Internal Server Error**：服务器发生内部错误。
- **503 Service Unavailable**：服务器暂时无法处理请求。

### 状态码详细分类

- **1xx（临时响应）** 表示临时响应并需要请求者继续执行操作的状态码。
  - `100` - 继续
  - `101` - 切换协议

- **2xx（成功）** 表示成功处理了请求的状态码。
  - `200` - OK
  - `201` - 已创建
  - `202` - 已接受
  - `203` - 非授权信息
  - `204` - 无内容
  - `205` - 重置内容

- **3xx（重定向）** 表示要完成请求需要进行进一步的操作。
  - `300` - 多种选择
  - `301` - 永久移动
  - `302` - 临时移动
  - `303` - 查看其它位置
  - `304` - 未修改
  - `305` - 使用代理
  - `307` - 临时重定向

- **4xx（客户端错误）** 这些状态码表示请求可能出错，妨碍了服务器的处理。
  - `400` - 错误请求
  - `401` - 未授权
  - `403` - 禁止
  - `404` - 未找到
  - `405` - 方法禁用
  - `406` - 不接受
  - `407` - 需要代理授权
  - `408` - 请求超时
  - `410` - 已删除
  - `413` - 请求实体过大
  - `414` - 请求的URI过长

- **5xx（服务器错误）** 这些状态码表示服务器在尝试处理请求时发生内部错误。
  - `500` - 服务器内部错误
  - `501` - 尚未实施
  - `502` - 错误网关
  - `503` - 服务器不可用
  - `504` - 网关超时
  - `505` - HTTP版本不受支持

## 介绍下304过程

1. **强缓存阶段**：
    - 当浏览器请求资源时，首先检查资源的`Expires`和`Cache-Control`。`Expires`基于特定的日期/时间失效，但如果用户更改了本地时间，可能会影响其有效性。而`Cache-Control: max-age`则定义了资源的最大生存时间，超过该时间则认为缓存失效。

2. **协商缓存阶段**：
    - 当强缓存失效后，浏览器会发送请求到服务器进行协商缓存验证。
    - 服务器可以使用`ETag`来验证资源是否已更改。`ETag`确保每个资源是唯一的，资源的任何更改都会导致`ETag`值的更改。当浏览器再次请求该资源时，它会发送`If-None-Match`头，该头的值为上次返回的`ETag`值。如果值匹配，服务器会返回`304 Not Modified`，表示资源未更改并且可以使用缓存。
    - 另一个验证方法是使用`Last-Modified`和`If-Modified-Since`头。服务器会在首次提供资源时返回`Last-Modified`头，指示资源的最后修改日期。在后续请求中，浏览器会发送`If-Modified-Since`头，该头的值为上次返回的`Last-Modified`值。如果资源自此时间以来未更改，服务器会返回`304 Not Modified`。

此流程确保在可能的情况下从浏览器缓存中提供资源，而不是重新从服务器获取。这可以减少网络带宽的使用并加快页面加载速度。

## HTTP 请求跨域问题

### 1. 跨域的原理

**跨域** 是指由于浏览器的`同源策略`限制，一种源的网页尝试访问另一种源的资源时，会被阻止。这是浏览器为了安全性考虑加入的限制。\
**同源策略**，是指只要协议、域名或端口其中之一有所不同，就被视为是不同的源。\
**跨域原理**，即是为了绕过这些限制而采用的各种技巧。

### 2. 解决方案

- **JSONP**：
    利用 `<script>` 标签不受同源策略限制的特点，发送 GET 请求从而实现跨域请求数据。

    步骤：
    1. 创建一个`<script>`标签。
    2. 设置`<script>`的`src`属性为接口地址。
    3. 在接口参数中提供一个回调函数名，以便后端返回数据时调用。
    4. 定义回调函数以接收返回的数据。

    ```js
    // 动态创建 <script>
    var script = document.createElement('script');
    // 设置回调函数
    function getData(data) {
        console.log(data);
    }
    // 设置 <script> 的 src 属性，并设置请求地址
    script.src = 'http://localhost:3000/?callback=getData';
    // 将 <script> 添加到页面中，发起请求
    document.body.appendChild(script);
    ```

    **JSONP 的缺点**：
    1. 只支持 GET 请求。
    2. 需要服务端返回指定格式的数据。

- **document.domain**：用于主域名相同但子域名不同的情况。

- **window.name**：不同域的页面可以通过设置相同的`window.name`值来共享数据。

- **CORS**：
    CORS (Cross-origin resource sharing) 是一种机制，允许在一个域名上运行的网页应用程序请求来自另一个域名的资源。其核心是服务器设置相关的 CORS HTTP 响应头。

    1. 浏览器会自动添加`Origin`头部，标明请求来源。
    2. 服务器根据设置的响应头决定是否允许跨域请求。

    **预检请求**：对于某些类型的跨域请求，浏览器会首先发送一个预检请求，询问目标资源的服务器是否接受该跨域请求。

- **Proxy代理 + Nginx**：
    使用反向代理服务器如 Nginx，将请求转发到实际的后端服务器上，从而绕过浏览器的同源策略。

- **window.postMessage()**：使用HTML5的`postMessage`方法进行跨域通信。

跨域传送门 ☞ [跨域，不可不知的基础概念](https://juejin.cn/post/7003232769182547998)

## 粘包问题分析与对策

TCP粘包是指发送方发送的多个包，在接收方被接收时合并为一个包。与之相反的，UDP由于保留消息边界，不会出现粘包现象。

### 粘包出现原因

主要是因为TCP基于字节流，而UDP基于消息。在流传输中，TCP会尽量确保传输效率，可能会将多个小包合并为一个大包进行传输。

### 对策

1. 发送方可以设置TCP的PUSH操作，强制立即发送数据，而不等待发送缓冲区满。
2. 接收方可以优化程序设计，尽快处理并接收数据，避免数据在接收缓冲区中积压。
3. 人为分包发送，例如每次发送固定大小的数据包。

以上方法均有缺点，如降低传输效率或增加处理复杂性。最实用的方法可能是接收方预处理数据，将接收到的数据进行解包操作，这种方法经实验表明是高效且可行的。

以下是对您提供的文档的完善和修复：

## 浏览器的缓存机制: 强制缓存 & 协商缓存

当浏览器与服务器进行通信，它采用的是应答模式。简言之，浏览器发起HTTP请求，然后服务器响应该请求。当浏览器第一次从服务器获取请求结果后，它会根据响应报文的HTTP头部中的缓存标识来决定是否要缓存结果。如果决定缓存，浏览器会将请求结果和缓存标识保存在其缓存中。

为了进一步理解，我们可以分析下图的简化流程：

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image)

从上图我们可以得知：

- 浏览器在每次发起请求前，会先在其缓存中查找该请求的结果以及缓存标识。
- 浏览器在接收到每个请求的返回结果后，会将该结果及其缓存标识保存在浏览器缓存中。

基于上述两点，我们可以深入研究浏览器缓存机制。这里，我们按照是否需要向服务器重新发起HTTP请求，将缓存过程分为两大部分：`强制缓存`和`协商缓存`。

- **强制缓存**

    强制缓存是指浏览器在检查其缓存中是否有某个请求结果，并基于该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文头部，并与请求结果一起返回。控制强制缓存的字段有 `Expires` 和 `Cache-Control`，其中`Cache-Control`的优先级比`Expires`高。

    强制缓存的主要情况有三种：

    1. 浏览器缓存中不存在该请求的结果和缓存标识，或者该结果已经过期。此时强制缓存失效，浏览器直接向服务器发起新请求。
    2. 浏览器缓存中有该请求的结果和缓存标识，但结果已经过期。此时强制缓存失效，浏览器进入协商缓存过程。
    3. 浏览器缓存中有该请求的结果和缓存标识，且结果尚未过期。此时强制缓存生效，浏览器直接使用缓存中的结果。

- **协商缓存**

    当强制缓存失效后，协商缓存开始起作用。这是一个浏览器携带缓存标识向服务器发起请求的过程，服务器会根据缓存标识来决定是否使用缓存。协商缓存的标识也是在响应报文的HTTP头部中返回的，关键的字段有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`，其中`Etag / If-None-Match`的优先级比`Last-Modified / If-Modified-Since`高。

    协商缓存的主要情况有两种：

    1. 服务器认为缓存仍然有效，返回HTTP 304状态码，告诉浏览器可以使用缓存。
    2. 服务器认为缓存已经过期或无效，返回HTTP 200状态码和新的请求结果。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image)

更多详细信息，请访问：[彻底理解浏览器的缓存机制](https://juejin.cn/post/6992843117963509791)

## 客户端与服务端长连接的几种方式

1. **Ajax 轮询**

    **实现原理**：Ajax 轮询是指客户端每间隔一段时间向服务端发起请求，从而保持数据的同步。

    **优点**：可以实现基础的数据更新，特别是当间隔时间较短。

    **缺点**：尽管模拟了实时传输，但它不是真正的即时通讯。可能存在服务端数据已更新但客户端未发起请求，或者客户端请求时，服务端数据并未更新的情况。导致多次无用请求，效率低下且数据更新可能不及时。

2. **Long Poll 长轮询**

    **实现原理**：
    当客户端发送请求后，如果服务器没有数据返回，它不会立即关闭连接，而是将请求挂起。只有当有数据需要返回给客户端时，服务器才会发送响应。接着，客户端会再次发起请求，形成轮询。

    **优点**：减少了无用的网络传输，确保每次请求都有数据返回，不会持续占用线程。

    **缺点**：在高并发环境中可能难以应对，因为服务器需要维护多个长时间的连接。此外，服务器不能主动向客户端推送数据。

3. **Iframe 长连接**

    **实现原理**：  
    网页中嵌入一个 iframe 标签，其 src 属性指向一个长连接请求。服务端可以通过这个连接持续地向客户端传输信息。

    **优点**：能够实时传输消息。

    **缺点**：可能会消耗大量的服务器资源。

4. **WebSocket**

    **实现原理**：
    WebSocket 支持客户端与服务端的双向通信。与 HTTP 不同，WebSocket 只需建立一次连接，即可实现持续的数据交换。

    **优点**：  
    - 双向通信：客户端和服务端都可以主动发起通讯。
    - 无同源限制：客户端可以与任意服务器通信，无跨域问题。
    - 数据轻量：与 HTTP 相比，WebSocket 在数据传输时无需带有冗余的请求头。
    - 高效：由于仅需要建立一次连接，数据传输效率更高。

    **缺点**：  
    - 需要后端的业务代码非常稳定。
    - 长连接可能受到网络限制，需要处理重连。
    - 兼容性问题，如只支持 IE10 及以上版本。
    - 维护长连接有一定的服务器成本。
    - 与 HTTP 相比，WebSocket 的生态圈较小，问题难以快速解决。

## 利用Socket建立网络连接的步骤

建立 Socket 连接至少需要一对套接字，其中一个位于客户端，称为 `ClientSocket`，另一个位于服务器端，称为 `ServerSocket`。

套接字之间的连接可以分为以下三个步骤：

1. **服务器监听**：  
   服务器端的套接字会持续监听网络状态，等待客户端的连接请求。

2. **客户端请求**：  
   客户端的套接字需要指明要连接的服务器端套接字的地址和端口号，然后向其发起连接请求。

3. **连接确认**：  
   当服务器端套接字接收到客户端的连接请求后，它会创建一个新的线程来处理该请求。一旦客户端确认了服务器的描述信息，双方就会正式建立连接。此后，服务器端套接字会继续监听，以等待其他客户端的连接请求。

## 非对称加密RSA

### 简介

1. 对称加密算法和非对称加密算法是两种主要的加密方法。
2. 非对称加密是计算机通信安全的基石，能够确保数据的安全传输。
3. 非对称加密算法需要两个密钥：公开密钥（public key）和私有密钥（private key）。
4. 公开密钥和私有密钥是一对。

- 使用公开密钥加密的数据，只有对应的私有密钥才能解密。
- 使用私有密钥加密的数据，只有对应的公开密钥才能解密。

### 特点

- 算法复杂度高，安全性主要依赖于算法和密钥。
- 相对于对称加密，非对称加密的加密和解密速度较慢。

### 与对称加密算法的对比

- 对称加密使用同一个密钥进行加密和解密，该密钥需要保持私密。
- 非对称加密使用两个密钥，其中一个可以公开。

### RSA应用场景

由于RSA算法的加密解密速度相对较慢，因此在实际应用中，通常会结合对称加密方法。即，数据的加密和解密使用对称加密算法（如AES），而对称加密所需的密钥则使用RSA算法加密进行传输。

---

## HTTP1、HTTP2、HTTP3

HTTP/2 相较于 HTTP/1.1 提高了网页的加载性能，减少了许多传统的性能优化工作。然而，HTTP/2 也有其限制和问题，这就是 HTTP/3 出现的原因。

### **HTTP1.1 的缺陷**

1. **高延迟 — 队头阻塞 (Head-Of-Line Blocking)**  
    当一系列按顺序发送的请求中的某个请求被阻塞，它后面的所有请求也会被阻塞，导致客户端不能及时接收数据。

    **解决办法：**
    - 分散同一页面的资源到不同的域名，提升连接上限。
    - 合并小文件减少请求数量，如使用精灵图。
    - 使用内联（Inlining）资源，例如将图片数据直接嵌入到CSS中，减少请求次数。
    - 合并文件以减少网络请求。

2. **无状态特性 — 阻碍交互**  
    HTTP协议本身是无状态的，意味着每个请求都被视为独立的，没有记忆之前的交互。同时，请求和响应中的头信息（Header）可能会因为重复内容而变得冗余。

3. **明文传输 — 安全风险**  
    在HTTP/1.1中，传输的所有内容都是明文的，因此存在数据被窃取和篡改的风险。

4. **不支持服务端推送**

> **记忆口诀：** 队头阻塞高延迟，无状态阻交互，明文传输易受攻，服务推送不支持。

### **HTTP 1.1 的排队问题**

HTTP 1.1 允许多个文件在单一的TCP连接上进行传输，以减少TCP的握手次数。但这种方式导致文件请求需要排队，从而引入了队头阻塞问题。由于浏览器限制了单一域名下的并行TCP连接数（通常为6个），在一个典型的网站上可能有数十到数百个资源需要加载，这导致了排队。HTTP/2 正在努力解决这个问题。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecdc60670194df7957ee59e1f56701f~tplv-k3u1fbpfcp-watermark.image?)

## SPDY 协议与 HTTP/2 简介

### 1. HTTP/2 简介

HTTP/2 是为替代现行的 HTTP 协议（HTTP/1.x）而设计的，但它不是完全重写。**HTTP/2 基于 SPDY，并专注于性能，其最主要的目标是在用户和网站间只使用一个连接（connection）。**

### 2. HTTP/2 新特性

#### 1) 二进制传输

HTTP/2 减少了传输数据量，这主要是因为它使用了二进制方式传输和 Header 压缩。与 HTTP/1.x 的纯文本形式的报文不同，HTTP/2 采用二进制格式传输数据，使得协议解析更为高效。此外，HTTP/2 将请求和响应数据分割为更小的帧，并且它们都采用二进制编码。

#### 2) Header 压缩

HTTP/2 使用了专门的 "HPACK" 压缩算法，而非传统的压缩方法。通过在客户端和服务器两端建立“字典”，并使用索引号表示重复的字符串以及采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

#### 3) 多路复用

HTTP/2 采用了多路复用技术，有效解决了浏览器限制同一域名下的请求数量的问题，并使其更容易实现全速传输。

#### 4) Server Push

HTTP/2 修改了传统的“请求-应答”模式。在此模式下，服务器不仅可以被动地响应请求，还可以主动向客户端发送消息，减少等待延迟，这被称为 "服务器推送"（Server Push 或 Cache push）。

#### 5) 提高安全性

虽然 HTTP/2 继续采用 HTTP/1 的“明文”传输方式并且不强制使用加密通信，但由于 HTTPS 趋势明显，并且主流的浏览器如 Chrome、Firefox 等都已经公开宣布只支持加密的 HTTP/2，**因此实际上的 HTTP/2 多数是加密的**。通常，HTTP/2 都是使用 "https" 协议名，在 TLS 上运行。HTTP/2 协议定义了两个字符串标识符：“h2" 表示加密的 HTTP/2，“h2c” 表示明文的 HTTP/2。

#### 6) 防止队头阻塞

与 HTTP/1.1 不同，HTTP/2 在处理大文件的阻塞时表现得更为出色。如果其中一个文件被阻塞，其它文件的传输不会受到影响。

### HTTP/2 的缺点

虽然 HTTP/2 解决了很多 HTTP/1.x 的问题，但由于其底层依赖于 TCP 协议，仍然存在一些问题：

1. TCP 以及 TCP+TLS 的连接建立时的延迟。
2. TCP 的队头阻塞问题并未完全解决。
3. 多路复用可能会导致服务器的压力增加，也更容易出现超时。

### HTTP/3 新特性

#### 1. HTTP/3 简介

Google 在推广 SPDY 时也提出了基于 UDP 的 "QUIC" 协议，意在使用 QUIC 替代 TCP 作为传输协议。而 "HTTP over QUIC" 实际上就是 HTTP/3，这一新版本完美地解决了队头阻塞的问题。

QUIC 虽然基于 UDP，但新增了很多功能。接下来，我们将重点介绍 QUIC 的一些新功能。

#### 2. QUIC 新功能

QUIC 是基于 UDP 的，这意味着它是无连接的，没有 TCP 中的“握手”和“挥手”过程，从而达到更快的连接速度。尽管 UDP 本身不保证传输的可靠性，但 QUIC 在其基础上增加了一系列功能来确保数据传输的可靠性。以下是 QUIC 的一些主要特点：

- **提供了类似于 TCP 的流量控制和传输可

靠性**，但在实现上有所不同，使其更具有扩展性和灵活性。
  
- **内建 TLS 支持**，不仅可以提供身份验证和加密，还可以在连接时减少多余的往返时间。
  
- **有效解决队头阻塞问题**，因为每个 QUIC 流都有自己的独立的传输上下文，而不是像 TCP 那样有全局上下文。

- **自带快速握手**，通过减少握手的往返次数，提高了连接的速度。

总结：SPDY、HTTP/2 和 HTTP/3 作为网络传输协议，都是为了提高网络传输的效率而设计。每一个版本都在前一个版本的基础上进行了改进，从而满足了互联网的高速发展需求。

## HTTP状态码

### 1xx (Informational): 信息性状态码

- 100：继续 (Continue) - 表示客户端可以继续发送请求。
- 101：切换协议 (Switching Protocols) - 表示服务器已经接受客户端的协议切换请求。

### 2xx (Successful): 成功状态码

- 200：成功 (OK) - 表示请求已成功完成，服务器返回所请求的资源。
- 201：已创建 (Created) - 提示知道新文件的URL，通常用于 POST 请求后的资源创建。
- 202：已接受 (Accepted) - 服务器已接受请求，但尚未处理完成。
- 203：非授权信息 (Non-Authoritative Information) - 返回的信息不确定或不完整。
- 204：无内容 (No Content) - 服务器成功处理请求，但没有返回任何内容。
- 205：重置内容 (Reset Content) - 服务器已完成请求，客户端应该重置视图。
- 206：部分内容 (Partial Content) - 服务器已经完成部分客户端的 GET 请求。

### 3xx (Redirection): 重定向状态码

- 300：多种选择 (Multiple Choices) - 表示请求的资源存在多个位置可供选择。
- 301：永久移动 (Moved Permanently) - 请求的网页被永久转移到新的URL。
- 302：临时移动 (Found) - 请求的网页被暂时转移到新的地址，但客户端应继续使用原始URL。
- 303：查看其他位置 (See Other) - 建议客户端访问其他URL或以不同方式访问当前资源。
- 304：未修改 (Not Modified) - 自从上次请求后，资源未发生修改，服务器返回此响应时不包含内容，用于缓存。
- 305：使用代理 (Use Proxy) - 客户端必须通过代理服务器访问请求的资源。
- 306：未使用 (Unused) - 在先前的HTTP版本中使用，现在已不再使用。
- 307：临时重定向 (Temporary Redirect) - 声明请求的资源临时性地移动。

### 4xx (Client Error): 客户端错误状态码

- 400：错误请求 (Bad Request) - 客户端请求存在语法错误，服务器无法理解。
- 401：未授权 (Unauthorized) - 请求未经授权，通常需要提供身份验证信息。
  - 401.1：未授权 - 登录失败。
  - 401.2：未授权 - 服务器配置问题导致登录失败。
  - 401.3：禁止访问资源。
  - 401.4：未授权 - 授权被筛选器拒绝。
  - 401.5：未授权 - ISAPI或CGI授权失败。
- 402：需要付款 (Payment Required) - 保留有效ChargeTo头响应。
- 403：禁止访问 (Forbidden) - 服务器收到请求，但拒绝提供服务。
  - 403.1：禁止访问 - 禁止可执行访问。
  - 403.2：禁止访问 - 禁止读访问。
  - 403.3：禁止访问 - 禁止写访问。
  - 403.4：禁止访问 - 要求SSL。
  - 403.5：禁止访问 - 要求SSL 128。
  - 403.6：禁止访问 - IP地址被拒绝。
  - 403.7：禁止访问 - 要求客户证书。
  - 403.8：禁止访问 - 禁止站点访问。
  - 403.9：禁止访问 - 连接的用户过多。
  - 403.10：禁止访问 - 配置无效。
  - 403.11：禁止访问 - 密码更改。
  - 403.12：禁止访问 - 映射器拒绝访问。
  - 403.13：禁止访问 - 客户证书已被吊销。
  - 403.15：禁止访问 - 客户访问许可过多。
  - 403.16：禁止访问 - 客户证书不可信或无效。
- 403.17：禁止访问 - 客户证书已经到期或尚未生效。
- 404：未找到 (Not Found) - 请求的资源不存在，通常由于输入了错误的URL。
- 405：方法不允许 (Method Not Allowed) - 用户请求中的方法不被允许。
- 406：不可接受 (Not Acceptable) - 请求的资源不支持客户端指定的数据格式。
- 407：需要代理认证 (Proxy Authentication Required) - 类似于401，客户端必须首先在代理服务器上得到授权。
- 408：请求超时 (Request Timeout) - 客户端没有在指定的时间内完成请求。
- 409：冲突 (Conflict) - 请求不能完成，因为当前资源状态不允许。
- 410：永远不可用 (Gone) - 服务器上不再有此资源，也没有进一步的参考地址。
- 411：需要长度 (Length Required) - 服务器拒绝请求，因为缺少有效的Content-Length头字段。
- 412：前提条件失败 (Precondition Failed) - 当前请求的一个或多个请求头字段在服务器上错误。
- 413：请求实体过大 (Request Entity Too Large) - 请求的资源大于服务器允许的大小。
- 414：请求的URI过长 (Request-URI Too Long) - 请求的资源URL超过了服务器允许的长度。
- 415：不支持的媒体类型 (Unsupported Media Type) - 请求资源不支持请求的项目格式。
- 416：请求范围不符合要

求 (Requested Range Not Satisfiable) - 请求中包含Range请求头字段，但范围无效。

- 417：未满足期望值 (Expectation Failed) - 服务器无法满足Expect头字段指定的期望值。

### 5xx (Server Error): 服务器错误状态码

- 500：服务器内部错误 (Internal Server Error) - 服务器遇到错误，无法完成请求。
  - 500.100：内部服务器错误 - ASP 错误。
  - 500-11：服务器关闭。
  - 500-12：应用程序重新启动。
  - 500-13：服务器太忙。
  - 500-14：应用程序无效。
  - 500-15：不允许请求global.asa。
- 501：未实现 (Not Implemented) - 服务器不支持请求的功能。
- 502：网关错误 (Bad Gateway) - 作为网关或代理服务器的服务器从上游服务器接收到无效的响应。
- 503：服务不可用 (Service Unavailable) - 服务器目前无法使用，通常由于超载或停机维护，一段时间后可能恢复正常。

## 认识HTTP

![HTTP图标](https://user-gold-cdn.xitu.io/2020/1/10/16f8f77381d78ded?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

按照范围的大小，HTTP可以分为三个层次：协议 > 传输 > 超文本。下面对这三个层次进行解释：

- **超文本**：在互联网早期，信息只能保存在本地，无法与其他电脑进行交互。信息以文本形式存在，文本是计算机可解析的有意义的二进制数据。随着互联网的发展，人们需要传输图片、音频、视频，以及实现超链接跳转。这扩展了文本的语义，这种扩展后的文本称为超文本（Hypertext）。

- **传输**：两台计算机之间建立互联关系进行通信，超文本会被解析成二进制数据包，并由传输载体（如同轴电缆、电话线、光缆）负责将数据包从一个终端传输到另一个终端。请求方和应答方可以交换角色，它们之间的关系是相互的。

- **协议**：网络协议是一些规范，用于在网络中传递、管理信息。就像人类社会需要遵循法律一样，计算机之间的通信需要遵守一定的规则，这些规则被称为网络协议。HTTP是一个用于在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

## 因特网网络模型

![因特网网络模型](https://user-gold-cdn.xitu.io/2020/1/10/16f8f773aa80e2bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- **应用层**：包括网络应用程序和网络协议，如HTTP、SMTP、FTP和DNS等。应用层协议分布在多个端系统上，应用层信息分组称为报文（message）。

- **运输层**：在应用程序之间传送应用程序报文，主要有TCP和UDP两种传输协议。TCP提供可靠的连接和流量控制，而UDP提供无连接服务。

- **网络层**：负责将数据报从一台主机移动到另一台主机，其中最重要的协议是IP协议，用于确定数据包的路由。网络层中的数据包称为数据报（datagram）。

- **链路层**：提供将帧从一个节点传输到另一个节点的服务，如以太网、WiFi和DOCSIS等。链路层中的数据包称为帧（frame）。

- **物理层**：将比特从一个节点传输到另一个节点，具体实现与物理传输介质有关，如双绞铜线、同轴电缆和光纤等。

因特网模型与OSI模型的区别在于它省略了表示层和会话层，更加简化，只关注了网络通信的关键层次。
