import{_ as s,o as n,c as l,Q as a}from"./chunks/framework.aea2adc8.js";const E=JSON.parse('{"title":"网络复习","description":"","frontmatter":{},"headers":[],"relativePath":"guide/computer/network/review.md","filePath":"guide/computer/network/review.md","lastUpdated":1707202110000}'),o={name:"guide/computer/network/review.md"},e=a(`<h1 id="网络复习" tabindex="-1">网络复习 <a class="header-anchor" href="#网络复习" aria-label="Permalink to &quot;网络复习&quot;">​</a></h1><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><p>HTTP 是互联网上应用最为广泛的一种网络协议。它是一个客户端和服务器端请求和应答的协议，基于 TCP/IP 进行通信。HTTP 主要用于从 WWW 服务器传输超文本到本地浏览器，故称为“超文本传输协议”。</p><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p>HTTP协议定义了 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何将 Web 页面传送给客户端。HTTP 通信开始时，客户端向服务器发送一个请求报文，服务器则以一个响应报文进行回复。</p><h3 id="请求-响应的步骤" tabindex="-1">请求/响应的步骤 <a class="header-anchor" href="#请求-响应的步骤" aria-label="Permalink to &quot;请求/响应的步骤&quot;">​</a></h3><ol><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端（浏览器）解析HTML内容</li></ol><blockquote><p>记忆口诀：连接、发送、响应三步走，释放后解析不放过。</p></blockquote><h3 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-label="Permalink to &quot;请求方法&quot;">​</a></h3><ul><li>GET: 请求指定的页面信息，并返回实体主体。</li><li>HEAD: 与 GET 方法类似，但服务器在响应中只返回头部信息，不返回实体的主体。</li><li>POST: 向指定资源提交数据，请求服务器进行处理。这可能导致资源的状态改变或服务器上的其他一些操作。</li><li>PUT: 从客户端向服务器传送数据，用于更新或创建资源。</li><li>DELETE: 请求服务器删除指定的页面。</li><li>CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS: 允许客户端查看服务器的性能。</li><li>TRACE: 回显服务器收到的请求，主要用于测试或诊断。</li><li>PATCH: 对资源进行部分修改。</li></ul><h3 id="http报文的组成成分" tabindex="-1">HTTP报文的组成成分 <a class="header-anchor" href="#http报文的组成成分" aria-label="Permalink to &quot;HTTP报文的组成成分&quot;">​</a></h3><p>HTTP 报文主要由请求报文和响应报文组成。其中，</p><ul><li><strong>请求报文</strong> 包括：请求行、请求头、空行、请求体，请求行由以下组成：HTTP方法、URL、HTTP版本</li><li><strong>响应报文</strong> 包括：状态行、响应头、空行、响应体</li></ul><p><strong>Request Header 示例:</strong></p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#FFAB70;">1.</span><span style="color:#E1E4E8;"> GET /sample.Jsp HTTP/1.1  // 请求行</span></span>
<span class="line"><span style="color:#FFAB70;">2.</span><span style="color:#E1E4E8;"> Host: www.uuid.online  // 请求的目标域名</span></span>
<span class="line"><span style="color:#FFAB70;">3.</span><span style="color:#E1E4E8;"> Origin: http://localhost:8081  // 请求的来源域名和端口号</span></span>
<span class="line"><span style="color:#FFAB70;">4.</span><span style="color:#E1E4E8;"> Referer: https://localhost:8081/link?query=xxxxx  // 请求资源的完整URI</span></span>
<span class="line"><span style="color:#FFAB70;">5.</span><span style="color:#E1E4E8;"> User-Agent: Mozilla/5.0 ... Safari/537.36  // 浏览器信息</span></span>
<span class="line"><span style="color:#FFAB70;">6.</span><span style="color:#E1E4E8;"> Cookie: BAIDUID=FA89F036:... sugstore=0  // 当前域名下的Cookie</span></span>
<span class="line"><span style="color:#FFAB70;">7.</span><span style="color:#E1E4E8;"> Accept: text/html,image/apng  // 希望接受的数据类型</span></span>
<span class="line"><span style="color:#FFAB70;">8.</span><span style="color:#E1E4E8;"> Accept-Encoding: gzip, deflate  // 支持的压缩格式</span></span>
<span class="line"><span style="color:#FFAB70;">9.</span><span style="color:#E1E4E8;"> Accept-Language: zh-CN,zh;q=0.9  // 支持的语言</span></span>
<span class="line"><span style="color:#FFAB70;">10.</span><span style="color:#E1E4E8;"> Connection: keep-alive  // TCP连接控制</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#E36209;">1.</span><span style="color:#24292E;"> GET /sample.Jsp HTTP/1.1  // 请求行</span></span>
<span class="line"><span style="color:#E36209;">2.</span><span style="color:#24292E;"> Host: www.uuid.online  // 请求的目标域名</span></span>
<span class="line"><span style="color:#E36209;">3.</span><span style="color:#24292E;"> Origin: http://localhost:8081  // 请求的来源域名和端口号</span></span>
<span class="line"><span style="color:#E36209;">4.</span><span style="color:#24292E;"> Referer: https://localhost:8081/link?query=xxxxx  // 请求资源的完整URI</span></span>
<span class="line"><span style="color:#E36209;">5.</span><span style="color:#24292E;"> User-Agent: Mozilla/5.0 ... Safari/537.36  // 浏览器信息</span></span>
<span class="line"><span style="color:#E36209;">6.</span><span style="color:#24292E;"> Cookie: BAIDUID=FA89F036:... sugstore=0  // 当前域名下的Cookie</span></span>
<span class="line"><span style="color:#E36209;">7.</span><span style="color:#24292E;"> Accept: text/html,image/apng  // 希望接受的数据类型</span></span>
<span class="line"><span style="color:#E36209;">8.</span><span style="color:#24292E;"> Accept-Encoding: gzip, deflate  // 支持的压缩格式</span></span>
<span class="line"><span style="color:#E36209;">9.</span><span style="color:#24292E;"> Accept-Language: zh-CN,zh;q=0.9  // 支持的语言</span></span>
<span class="line"><span style="color:#E36209;">10.</span><span style="color:#24292E;"> Connection: keep-alive  // TCP连接控制</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="get与post的区别" tabindex="-1">GET与POST的区别 <a class="header-anchor" href="#get与post的区别" aria-label="Permalink to &quot;GET与POST的区别&quot;">​</a></h3><ol><li><strong>浏览器回退表现不同</strong>：GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li><strong>浏览器对请求地址的处理不同</strong>：GET 请求的地址会被浏览器主动缓存，而 POST 不会，除非手动设置。</li><li><strong>浏览器对响应的处理不同</strong>：GET 请求的参数会被完整地保留在浏览器的历史记录里，而 POST 的参数不会被保留。</li><li><strong>参数大小不同</strong>：GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li><li><strong>安全性不同</strong>：GET 参数通过 URL 传递，可能会被暴露，相对不安全；而 POST 参数存放在 Request Body 中，相对更安全。</li><li><strong>针对数据操作的类型不同</strong>：GET 主要用于查询数据，而 POST 用于添加、修改或删除数据。简言之，GET 是只读的，而 POST 是用于写操作的。</li></ol><p><strong>Response Header 示例:</strong></p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">HTTP/1.1 200 OK  // 状态行，其中200是状态代码，表示请求成功，OK是状态消息</span></span>
<span class="line"><span style="color:#E1E4E8;">Date: Tue, 25 Oct 2023 15:30:20 GMT  // 响应生成的日期和时间</span></span>
<span class="line"><span style="color:#E1E4E8;">Server: Apache/2.4.41 (Unix)  // 提供此响应的服务器类型和版本信息。</span></span>
<span class="line"><span style="color:#E1E4E8;">Last-Modified: Mon, 23 Oct 2023 14:30:58 GMT  // 此资源上次修改的日期和时间。</span></span>
<span class="line"><span style="color:#E1E4E8;">ETag: &quot;e2a-5d8880c9c2b40&quot;  // 资源的版本标识符。用于缓存管理和确保数据的一致性。</span></span>
<span class="line"><span style="color:#E1E4E8;">Accept-Ranges: bytes  // 指定服务器接受的范围类型，通常用于断点续传。</span></span>
<span class="line"><span style="color:#E1E4E8;">Content-Length: 374  // 响应正文的长度（以字节为单位）。</span></span>
<span class="line"><span style="color:#E1E4E8;">Cache-Control: max-age=3600, public  // 指定缓存指令，告诉客户端如何缓存响应内容。</span></span>
<span class="line"><span style="color:#E1E4E8;">Content-Type: text/html; charset=UTF-8  // 响应内容的MIME类型和字符集。</span></span>
<span class="line"><span style="color:#E1E4E8;">Connection: close  // 响应头用来告诉客户端服务器想要如何处理网络连接。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">HTTP/1.1 200 OK  // 状态行，其中200是状态代码，表示请求成功，OK是状态消息</span></span>
<span class="line"><span style="color:#24292E;">Date: Tue, 25 Oct 2023 15:30:20 GMT  // 响应生成的日期和时间</span></span>
<span class="line"><span style="color:#24292E;">Server: Apache/2.4.41 (Unix)  // 提供此响应的服务器类型和版本信息。</span></span>
<span class="line"><span style="color:#24292E;">Last-Modified: Mon, 23 Oct 2023 14:30:58 GMT  // 此资源上次修改的日期和时间。</span></span>
<span class="line"><span style="color:#24292E;">ETag: &quot;e2a-5d8880c9c2b40&quot;  // 资源的版本标识符。用于缓存管理和确保数据的一致性。</span></span>
<span class="line"><span style="color:#24292E;">Accept-Ranges: bytes  // 指定服务器接受的范围类型，通常用于断点续传。</span></span>
<span class="line"><span style="color:#24292E;">Content-Length: 374  // 响应正文的长度（以字节为单位）。</span></span>
<span class="line"><span style="color:#24292E;">Cache-Control: max-age=3600, public  // 指定缓存指令，告诉客户端如何缓存响应内容。</span></span>
<span class="line"><span style="color:#24292E;">Content-Type: text/html; charset=UTF-8  // 响应内容的MIME类型和字符集。</span></span>
<span class="line"><span style="color:#24292E;">Connection: close  // 响应头用来告诉客户端服务器想要如何处理网络连接。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="http请求跨域问题" tabindex="-1">HTTP请求跨域问题 <a class="header-anchor" href="#http请求跨域问题" aria-label="Permalink to &quot;HTTP请求跨域问题&quot;">​</a></h3><ul><li><p><strong>跨域的原理</strong></p><ul><li><strong>跨域</strong> 是指由于浏览器的<code>同源策略</code>限制，一个域的文档或脚本试图去请求另一个域的资源。</li><li><strong>同源策略</strong> 是一种约定，它是浏览器对 JavaScript 实施的安全限制。只要<code>协议</code>、<code>域名</code>、或<code>端口</code>有任何一个不同，那么两个域就被认为是不同的域。</li><li><strong>跨域原理</strong> 是指通过某种方式绕过这些安全限制，使得不同的域之间可以互相请求资源。</li></ul></li><li><p><strong>非同源限制</strong></p><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法对非同源网页的 DOM 和JS对象进行操作</li><li>无法向非同源地址发送 AJAX请求</li></ul></li><li><p><strong>解决方案</strong></p><ul><li><p><strong>JSONP</strong>： 利用<code>&lt;script&gt;</code>标签的src属性可以访问跨域的 js 脚本的特性，服务器返回一个调用某个函数的 js 代码，客户端再通过此函数接收数据。 <strong>缺点</strong> 只支持 GET 请求；需要后端配合返回指定格式的数据。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> script </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;script&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">script.src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;http://localhost:3000/?callback=getData&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">document.body.</span><span style="color:#B392F0;">appendChild</span><span style="color:#E1E4E8;">(script);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> script </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;script&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">(</span><span style="color:#E36209;">data</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(data);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">script.src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;http://localhost:3000/?callback=getData&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">document.body.</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(script);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p><strong>document.domain</strong>： 适用于子域名不同，但基础域名相同的情况。</p></li><li><p><strong>window.name</strong>： 所有窗口内的域名都共享同一个 window.name。</p></li><li><p><strong>CORS</strong>： 服务器设置<code>Access-Control-Allow-Origin</code> HTTP响应头，浏览器会允许跨域请求。</p></li><li><p><strong>proxy代理</strong>： 利用服务器端进行转发请求，从而绕过浏览器的同源策略。</p></li><li><p><strong>window.postMessage()</strong>： 利用 HTML5 的 postMessage 方法进行跨域通信。</p></li><li><p><strong>Websocket</strong>： 允许进行全双工通信的网络协议，可以进行跨域通信。</p></li></ul></li></ul><h3 id="http状态码及常见状态码" tabindex="-1">HTTP状态码及常见状态码 <a class="header-anchor" href="#http状态码及常见状态码" aria-label="Permalink to &quot;HTTP状态码及常见状态码&quot;">​</a></h3><h4 id="http状态码" tabindex="-1">HTTP状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;HTTP状态码&quot;">​</a></h4><ul><li><strong>1xx：指示信息类</strong> - 表示请求已接受，继续处理。</li><li><strong>2xx：指示成功类</strong> - 表示请求已成功被服务器接收、理解并接受。</li><li><strong>3xx：指示重定向</strong> - 表示要完成请求必须进行进一步的操作。</li><li><strong>4xx：指示客户端错误</strong> - 请求包含错误的语法或不能完成。</li><li><strong>5xx：指示服务器错误</strong> - 服务器在处理请求时出错。</li></ul><h4 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码&quot;">​</a></h4><ul><li><strong>200 OK</strong>：客户端请求成功。</li><li><strong>301 Moved Permanently</strong>：所请求的页面已永久重定向至新的URL。</li><li><strong>302 Found</strong>：所请求的页面已临时重定向至新的URL。</li><li><strong>304 Not Modified</strong>：资源自上次请求后未发生变化。</li><li><strong>403 Forbidden</strong>：服务器拒绝了客户端的请求。</li><li><strong>404 Not Found</strong>：服务器找不到请求的资源。</li><li><strong>500 Internal Server Error</strong>：服务器发生内部错误。</li><li><strong>503 Service Unavailable</strong>：服务器暂时无法处理请求。</li></ul><h4 id="状态码详细分类" tabindex="-1">状态码详细分类 <a class="header-anchor" href="#状态码详细分类" aria-label="Permalink to &quot;状态码详细分类&quot;">​</a></h4><ul><li><p><strong>1xx（临时响应）</strong> 表示临时响应并需要请求者继续执行操作的状态码。</p><ul><li><code>100</code> - 继续</li><li><code>101</code> - 切换协议</li></ul></li><li><p><strong>2xx（成功）</strong> 表示成功处理了请求的状态码。</p><ul><li><code>200</code> - OK</li><li><code>201</code> - 已创建</li><li><code>202</code> - 已接受</li><li><code>203</code> - 非授权信息</li><li><code>204</code> - 无内容</li><li><code>205</code> - 重置内容</li></ul></li><li><p><strong>3xx（重定向）</strong> 表示要完成请求需要进行进一步的操作。</p><ul><li><code>300</code> - 多种选择</li><li><code>301</code> - 永久移动</li><li><code>302</code> - 临时移动</li><li><code>303</code> - 查看其它位置</li><li><code>304</code> - 未修改</li><li><code>305</code> - 使用代理</li><li><code>307</code> - 临时重定向</li></ul></li><li><p><strong>4xx（客户端错误）</strong> 这些状态码表示请求可能出错，妨碍了服务器的处理。</p><ul><li><code>400</code> - 错误请求</li><li><code>401</code> - 未授权</li><li><code>403</code> - 禁止</li><li><code>404</code> - 未找到</li><li><code>405</code> - 方法禁用</li><li><code>406</code> - 不接受</li><li><code>407</code> - 需要代理授权</li><li><code>408</code> - 请求超时</li><li><code>410</code> - 已删除</li><li><code>413</code> - 请求实体过大</li><li><code>414</code> - 请求的URI过长</li></ul></li><li><p><strong>5xx（服务器错误）</strong> 这些状态码表示服务器在尝试处理请求时发生内部错误。</p><ul><li><code>500</code> - 服务器内部错误</li><li><code>501</code> - 尚未实施</li><li><code>502</code> - 错误网关</li><li><code>503</code> - 服务器不可用</li><li><code>504</code> - 网关超时</li><li><code>505</code> - HTTP版本不受支持</li></ul></li></ul><h2 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h2><h3 id="https-的基本概念" tabindex="-1">HTTPS 的基本概念 <a class="header-anchor" href="#https-的基本概念" aria-label="Permalink to &quot;HTTPS 的基本概念&quot;">​</a></h3><p>HTTPS 是 HTTP 下加入 SSL/TLS 层进行加密的协议，它旨在提供安全的 HTTP 通道。</p><p>HTTPS 协议的主要作用是：</p><ul><li>建立一个信息安全的通道，确保数据的加密传输。</li><li>通过证书验证服务器的真实性，防止中间人攻击。</li></ul><h3 id="http-和-https-的区别" tabindex="-1">HTTP 和 HTTPS 的区别？ <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;HTTP 和 HTTPS 的区别？&quot;">​</a></h3><ul><li>HTTP 是明文传输的超文本传输协议，而 HTTPS 是具有安全性的 SSL/TLS 加密传输协议。</li><li>HTTPS 需要使用 CA 证书，而这通常是有成本的。</li><li>HTTP 和 HTTPS 使用不同的端口，通常 HTTP 使用 80，而 HTTPS 使用 443。</li><li>HTTP 的连接是无状态的，而 HTTPS 的连接除了是有状态的，还是加密的。</li></ul><blockquote><p>记忆口诀：明文传输与超文本，安全等级各有差异。CA 证书需付费，HTTP 无状态、HTTPS 加密传。</p></blockquote><h3 id="https-协议的工作原理" tabindex="-1">HTTPS 协议的工作原理 <a class="header-anchor" href="#https-协议的工作原理" aria-label="Permalink to &quot;HTTPS 协议的工作原理&quot;">​</a></h3><p>HTTPS 在与 Web 服务器通信时的步骤如下：</p><ol><li>客户端通过 HTTPS URL 请求服务器，要求建立 SSL/TLS 链接。</li><li>服务器将其证书（含公钥）发送给客户端。</li><li>客户端与服务器协商确定加密算法和密钥。</li><li>客户端使用公钥加密一个随机的会话密钥，并发送给服务器。</li><li>服务器使用私钥解密得到会话密钥。</li><li>双方使用会话密钥进行加密通信。</li></ol><blockquote><p>记忆口诀：HTTPS 连接步骤六，密钥交换安全必。</p></blockquote><h3 id="https-协议的优缺点" tabindex="-1">HTTPS 协议的优缺点 <a class="header-anchor" href="#https-协议的优缺点" aria-label="Permalink to &quot;HTTPS 协议的优缺点&quot;">​</a></h3><ul><li>HTTPS 比 HTTP 更加<strong>安全</strong>，能够保护数据在传输过程中不被窃取或篡改，确保数据完整性。</li><li>HTTPS 握手阶段相对耗时，可能会导致页面加载时间增加约50%，并可能导致增加10%~20%的电量消耗。</li><li>HTTPS 的<strong>缓存效率</strong>低于 HTTP，可能增加数据传输的开销。</li><li>SSL 证书需要购买，功能更强大的证书通常费用更高。</li><li>SSL 证书需要与 IP 地址绑定，这意味着不能在同一个 IP 地址上绑定多个域名，这种做法受到IPv4资源的限制。</li></ul><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><h3 id="tcp-ip-网络模型" tabindex="-1">TCP/IP 网络模型 <a class="header-anchor" href="#tcp-ip-网络模型" aria-label="Permalink to &quot;TCP/IP 网络模型&quot;">​</a></h3><p>TCP/IP模型是互联网的核心，由一系列网络协议组成。这些协议可以分为四层：链路层、网络层、传输层和应用层。</p><ul><li><strong>链路层</strong>：负责封装和解封装 IP 报文，以及发送和接收 ARP/RARP 报文等。</li><li><strong>网络层</strong>：负责选择最优的路由路径，将分组报文发送到目标网络或主机。</li><li><strong>传输层</strong>：对报文进行分段和重组，并根据 TCP 或 UDP 协议格式进行封装。</li><li><strong>应用层</strong>：提供各种应用程序接口，如 HTTP、FTP、Telnet、DNS、SMTP 等。</li></ul><h3 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h3><ol><li>第一次握手：客户端发送 SYN 包 (SYN=j) 到服务器，并转换到 SYN_SENT 状态，等待服务器确认。</li><li>第二次握手：服务器接收到 SYN 包后确认客户端的 SYN（ACK=j+1），同时发送自己的 SYN 包（SYN=k），即发送 SYN+ACK 包，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包后，发送确认包 ACK(ACK=k+1)，完成后，双方进入 ESTABLISHED 状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包不包含数据内容。只有在三次握手完毕后，客户端和服务器才开始正式传输数据。</p></blockquote><h3 id="tcp-四次挥手" tabindex="-1">TCP 四次挥手 <a class="header-anchor" href="#tcp-四次挥手" aria-label="Permalink to &quot;TCP 四次挥手&quot;">​</a></h3><ol><li>客户端发出连接释放报文，停止发送数据。此释放报文头部设置 FIN=1，序列号为 seq=u，随后客户端进入 FIN-WAIT-1 状态。</li><li>服务器收到释放报文后，发出确认报文，进入 CLOSE-WAIT 状态。</li><li>客户端收到服务器的确认后，进入 FIN-WAIT-2 状态，等待服务器的释放报文。</li><li>服务器发送最后的数据和连接释放报文，随后进入 LAST-ACK 状态。</li><li>客户端收到服务器的释放报文后，发送确认，然后进入 TIME-WAIT 状态。经过一段时间后，客户端进入 CLOSED 状态。</li><li>服务器收到客户端的确认后，立即进入 CLOSED 状态。</li></ol><h3 id="tcp-和-udp-的区别" tabindex="-1">TCP 和 UDP 的区别 <a class="header-anchor" href="#tcp-和-udp-的区别" aria-label="Permalink to &quot;TCP 和 UDP 的区别&quot;">​</a></h3><ol><li>TCP 是面向连接的，而 UDP 是无连接的。</li><li>TCP 仅支持单播传输，而 UDP 支持单播、多播和广播。</li><li>TCP 通过三次握手保证了连接的可靠性。而 UDP 是无连接且不可靠的，没有建立连接的步骤，发送端不确保数据的正确接收。</li><li>UDP 的头部开销小于 TCP，数据传输速率更快，更适合于要求实时性的应用。</li></ol><h2 id="cookie、sessionstorage、localstorage-的区别" tabindex="-1">Cookie、sessionStorage、localStorage 的区别 <a class="header-anchor" href="#cookie、sessionstorage、localstorage-的区别" aria-label="Permalink to &quot;Cookie、sessionStorage、localStorage 的区别&quot;">​</a></h2><p><strong>相同点</strong>：</p><ul><li>都是存储在客户端的技术。</li></ul><p><strong>不同点</strong>：</p><ul><li><p><strong>存储大小</strong>：</p><ul><li>cookie 数据大小不能超过4K。</li><li>sessionStorage 和 localStorage 可以存储约5M的数据。</li></ul></li><li><p><strong>生命周期</strong>：</p><ul><li>cookie 根据设置的过期时间持续有效。</li><li>localStorage 数据持久保存，即使浏览器关闭也不会丢失，除非用户主动删除数据。</li><li>sessionStorage 数据在当前浏览器窗口或标签页关闭后自动删除。</li></ul></li><li><p><strong>与服务器交互</strong>：</p><ul><li>cookie 数据在每次向服务器发送请求时都会被自动附带，无论是否需要。</li><li>sessionStorage 和 localStorage 数据只保存在本地，不会被自动发送到服务器。</li></ul></li></ul><h2 id="介绍下304过程" tabindex="-1">介绍下304过程 <a class="header-anchor" href="#介绍下304过程" aria-label="Permalink to &quot;介绍下304过程&quot;">​</a></h2><ol><li><p><strong>强缓存阶段</strong>：</p><ul><li>当浏览器请求资源时，首先检查资源的<code>Expires</code>和<code>Cache-Control</code>。<code>Expires</code>基于特定的日期/时间失效，但如果用户更改了本地时间，可能会影响其有效性。而<code>Cache-Control: max-age</code>则定义了资源的最大生存时间，超过该时间则认为缓存失效。</li></ul></li><li><p><strong>协商缓存阶段</strong>：</p><ul><li>当强缓存失效后，浏览器会发送请求到服务器进行协商缓存验证。</li><li>服务器可以使用<code>ETag</code>来验证资源是否已更改。<code>ETag</code>确保每个资源是唯一的，资源的任何更改都会导致<code>ETag</code>值的更改。当浏览器再次请求该资源时，它会发送<code>If-None-Match</code>头，该头的值为上次返回的<code>ETag</code>值。如果值匹配，服务器会返回<code>304 Not Modified</code>，表示资源未更改并且可以使用缓存。</li><li>另一个验证方法是使用<code>Last-Modified</code>和<code>If-Modified-Since</code>头。服务器会在首次提供资源时返回<code>Last-Modified</code>头，指示资源的最后修改日期。在后续请求中，浏览器会发送<code>If-Modified-Since</code>头，该头的值为上次返回的<code>Last-Modified</code>值。如果资源自此时间以来未更改，服务器会返回<code>304 Not Modified</code>。</li></ul></li></ol><p>此流程确保在可能的情况下从浏览器缓存中提供资源，而不是重新从服务器获取。这可以减少网络带宽的使用并加快页面加载速度。</p><h2 id="粘包问题分析与对策" tabindex="-1">粘包问题分析与对策 <a class="header-anchor" href="#粘包问题分析与对策" aria-label="Permalink to &quot;粘包问题分析与对策&quot;">​</a></h2><p>TCP粘包是指发送方发送的多个包，在接收方被接收时合并为一个包。与之相反的，UDP由于保留消息边界，不会出现粘包现象。</p><h3 id="粘包出现原因" tabindex="-1">粘包出现原因 <a class="header-anchor" href="#粘包出现原因" aria-label="Permalink to &quot;粘包出现原因&quot;">​</a></h3><p>主要是因为TCP基于字节流，而UDP基于消息。在流传输中，TCP会尽量确保传输效率，可能会将多个小包合并为一个大包进行传输。</p><h3 id="对策" tabindex="-1">对策 <a class="header-anchor" href="#对策" aria-label="Permalink to &quot;对策&quot;">​</a></h3><ol><li>发送方可以设置TCP的PUSH操作，强制立即发送数据，而不等待发送缓冲区满。</li><li>接收方可以优化程序设计，尽快处理并接收数据，避免数据在接收缓冲区中积压。</li><li>人为分包发送，例如每次发送固定大小的数据包。</li></ol><p>以上方法均有缺点，如降低传输效率或增加处理复杂性。最实用的方法可能是接收方预处理数据，将接收到的数据进行解包操作，这种方法经实验表明是高效且可行的。</p><p>以下是对您提供的文档的完善和修复：</p><h2 id="浏览器的缓存机制-强制缓存-协商缓存" tabindex="-1">浏览器的缓存机制: 强制缓存 &amp; 协商缓存 <a class="header-anchor" href="#浏览器的缓存机制-强制缓存-协商缓存" aria-label="Permalink to &quot;浏览器的缓存机制: 强制缓存 &amp; 协商缓存&quot;">​</a></h2><p>当浏览器与服务器进行通信，它采用的是应答模式。简言之，浏览器发起HTTP请求，然后服务器响应该请求。当浏览器第一次从服务器获取请求结果后，它会根据响应报文的HTTP头部中的缓存标识来决定是否要缓存结果。如果决定缓存，浏览器会将请求结果和缓存标识保存在其缓存中。</p><p>为了进一步理解，我们可以分析下图的简化流程：</p><p>从上图我们可以得知：</p><ul><li>浏览器在每次发起请求前，会先在其缓存中查找该请求的结果以及缓存标识。</li><li>浏览器在接收到每个请求的返回结果后，会将该结果及其缓存标识保存在浏览器缓存中。</li></ul><p>基于上述两点，我们可以深入研究浏览器缓存机制。这里，我们按照是否需要向服务器重新发起HTTP请求，将缓存过程分为两大部分：<code>强制缓存</code>和<code>协商缓存</code>。</p><ul><li><p><strong>强制缓存</strong></p><p>强制缓存是指浏览器在检查其缓存中是否有某个请求结果，并基于该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文头部，并与请求结果一起返回。控制强制缓存的字段有 <code>Expires</code> 和 <code>Cache-Control</code>，其中<code>Cache-Control</code>的优先级比<code>Expires</code>高。</p><p>强制缓存的主要情况有三种：</p><ol><li>浏览器缓存中不存在该请求的结果和缓存标识，或者该结果已经过期。此时强制缓存失效，浏览器直接向服务器发起新请求。</li><li>浏览器缓存中有该请求的结果和缓存标识，但结果已经过期。此时强制缓存失效，浏览器进入协商缓存过程。</li><li>浏览器缓存中有该请求的结果和缓存标识，且结果尚未过期。此时强制缓存生效，浏览器直接使用缓存中的结果。</li></ol></li><li><p><strong>协商缓存</strong></p><p>当强制缓存失效后，协商缓存开始起作用。这是一个浏览器携带缓存标识向服务器发起请求的过程，服务器会根据缓存标识来决定是否使用缓存。协商缓存的标识也是在响应报文的HTTP头部中返回的，关键的字段有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高。</p><p>协商缓存的主要情况有两种：</p><ol><li>服务器认为缓存仍然有效，返回HTTP 304状态码，告诉浏览器可以使用缓存。</li><li>服务器认为缓存已经过期或无效，返回HTTP 200状态码和新的请求结果。</li></ol></li></ul><p>更多详细信息，请访问：<a href="https://juejin.cn/post/6992843117963509791" target="_blank" rel="noreferrer">彻底理解浏览器的缓存机制</a></p><h2 id="客户端与服务端长连接的几种方式" tabindex="-1">客户端与服务端长连接的几种方式 <a class="header-anchor" href="#客户端与服务端长连接的几种方式" aria-label="Permalink to &quot;客户端与服务端长连接的几种方式&quot;">​</a></h2><ol><li><p><strong>Ajax 轮询</strong></p><p><strong>实现原理</strong>：Ajax 轮询是指客户端每间隔一段时间向服务端发起请求，从而保持数据的同步。</p><p><strong>优点</strong>：可以实现基础的数据更新，特别是当间隔时间较短。</p><p><strong>缺点</strong>：尽管模拟了实时传输，但它不是真正的即时通讯。可能存在服务端数据已更新但客户端未发起请求，或者客户端请求时，服务端数据并未更新的情况。导致多次无用请求，效率低下且数据更新可能不及时。</p></li><li><p><strong>Long Poll 长轮询</strong></p><p><strong>实现原理</strong>： 当客户端发送请求后，如果服务器没有数据返回，它不会立即关闭连接，而是将请求挂起。只有当有数据需要返回给客户端时，服务器才会发送响应。接着，客户端会再次发起请求，形成轮询。</p><p><strong>优点</strong>：减少了无用的网络传输，确保每次请求都有数据返回，不会持续占用线程。</p><p><strong>缺点</strong>：在高并发环境中可能难以应对，因为服务器需要维护多个长时间的连接。此外，服务器不能主动向客户端推送数据。</p></li><li><p><strong>Iframe 长连接</strong></p><p><strong>实现原理</strong>：<br> 网页中嵌入一个 iframe 标签，其 src 属性指向一个长连接请求。服务端可以通过这个连接持续地向客户端传输信息。</p><p><strong>优点</strong>：能够实时传输消息。</p><p><strong>缺点</strong>：可能会消耗大量的服务器资源。</p></li><li><p><strong>WebSocket</strong></p><p><strong>实现原理</strong>： WebSocket 支持客户端与服务端的双向通信。与 HTTP 不同，WebSocket 只需建立一次连接，即可实现持续的数据交换。</p><p><strong>优点</strong>：</p><ul><li>双向通信：客户端和服务端都可以主动发起通讯。</li><li>无同源限制：客户端可以与任意服务器通信，无跨域问题。</li><li>数据轻量：与 HTTP 相比，WebSocket 在数据传输时无需带有冗余的请求头。</li><li>高效：由于仅需要建立一次连接，数据传输效率更高。</li></ul><p><strong>缺点</strong>：</p><ul><li>需要后端的业务代码非常稳定。</li><li>长连接可能受到网络限制，需要处理重连。</li><li>兼容性问题，如只支持 IE10 及以上版本。</li><li>维护长连接有一定的服务器成本。</li><li>与 HTTP 相比，WebSocket 的生态圈较小，问题难以快速解决。</li></ul></li></ol><h2 id="利用socket建立网络连接的步骤" tabindex="-1">利用Socket建立网络连接的步骤 <a class="header-anchor" href="#利用socket建立网络连接的步骤" aria-label="Permalink to &quot;利用Socket建立网络连接的步骤&quot;">​</a></h2><p>建立 Socket 连接至少需要一对套接字，其中一个位于客户端，称为 <code>ClientSocket</code>，另一个位于服务器端，称为 <code>ServerSocket</code>。</p><p>套接字之间的连接可以分为以下三个步骤：</p><ol><li><p><strong>服务器监听</strong>：<br> 服务器端的套接字会持续监听网络状态，等待客户端的连接请求。</p></li><li><p><strong>客户端请求</strong>：<br> 客户端的套接字需要指明要连接的服务器端套接字的地址和端口号，然后向其发起连接请求。</p></li><li><p><strong>连接确认</strong>：<br> 当服务器端套接字接收到客户端的连接请求后，它会创建一个新的线程来处理该请求。一旦客户端确认了服务器的描述信息，双方就会正式建立连接。此后，服务器端套接字会继续监听，以等待其他客户端的连接请求。</p></li></ol><h2 id="非对称加密rsa" tabindex="-1">非对称加密RSA <a class="header-anchor" href="#非对称加密rsa" aria-label="Permalink to &quot;非对称加密RSA&quot;">​</a></h2><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h3><ol><li>对称加密算法和非对称加密算法是两种主要的加密方法。</li><li>非对称加密是计算机通信安全的基石，能够确保数据的安全传输。</li><li>非对称加密算法需要两个密钥：公开密钥（public key）和私有密钥（private key）。</li><li>公开密钥和私有密钥是一对。</li></ol><ul><li>使用公开密钥加密的数据，只有对应的私有密钥才能解密。</li><li>使用私有密钥加密的数据，只有对应的公开密钥才能解密。</li></ul><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>算法复杂度高，安全性主要依赖于算法和密钥。</li><li>相对于对称加密，非对称加密的加密和解密速度较慢。</li></ul><h3 id="与对称加密算法的对比" tabindex="-1">与对称加密算法的对比 <a class="header-anchor" href="#与对称加密算法的对比" aria-label="Permalink to &quot;与对称加密算法的对比&quot;">​</a></h3><ul><li>对称加密使用同一个密钥进行加密和解密，该密钥需要保持私密。</li><li>非对称加密使用两个密钥，其中一个可以公开。</li></ul><h3 id="rsa-应用场景" tabindex="-1">RSA 应用场景 <a class="header-anchor" href="#rsa-应用场景" aria-label="Permalink to &quot;RSA 应用场景&quot;">​</a></h3><p>由于RSA算法的加密解密速度相对较慢，因此在实际应用中，通常会结合对称加密方法。即，数据的加密和解密使用对称加密算法（如AES），而对称加密所需的密钥则使用RSA算法加密进行传输。</p><h2 id="http-版本" tabindex="-1">HTTP 版本 <a class="header-anchor" href="#http-版本" aria-label="Permalink to &quot;HTTP 版本&quot;">​</a></h2><h3 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP/0.9&quot;">​</a></h3><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong>。</p><p>HTTP/0.9 的一个完整的请求流程</p><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 <strong>ASCII 字符流</strong>返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是<strong>服务器也没有返回头信息</strong>，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><h3 id="http-1-0" tabindex="-1">HTTP 1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP 1.0&quot;">​</a></h3><p>HTTP 1.0 是在 1996 年引入的，由于在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求。</p><ul><li>HTTP 1.0 仅仅提供了<strong>最基本的认证</strong>，这时候用户名和密码还未经加密，因此很容易收到窥探。</li><li>HTTP/1.0 引入了<strong>请求头</strong>和<strong>响应头</strong>，它们都是以为 Key-Value 形式保存的</li><li>HTTP 1.0 被设计用来使用<strong>短链接</strong><ul><li>即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li></ul></li><li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li></ul><h3 id="http-1-1" tabindex="-1">HTTP 1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP 1.1&quot;">​</a></h3><p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p><ul><li>HTTP 1.1 使用了<strong>摘要算法</strong>来进行身份验证</li><li>HTTP 1.1 默认使用长连接（持久连接） <ul><li>长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。</li><li>长连接的连接时长可以通过<strong>请求头</strong>中的 keep-alive 来设置</li><li>持久连接在 HTTP/1.1 中是<strong>默认开启</strong>的</li></ul></li><li>HTTP 1.1 中新增加了 E-tag, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li><li>HTTP 1.1 支持断点续传，通过使用请求头中的 Range 来实现。</li></ul><h3 id="http-2-0" tabindex="-1">HTTP 2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP 2.0&quot;">​</a></h3><p>HTTP 2.0 是 2015 年开发出来的标准，HTTP/2 的一个核心特性是使用了 多路复用技术，因此它可以 通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题。</p><ul><li>头部压缩 <ul><li>由于 HTTP 1.1 经常会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致<strong>头部偏重</strong>。</li><li>HTTP 2.0 使用 HPACK 算法进行压缩。</li></ul></li><li>二进制格式 <ul><li>HTTP 2.0 使用了更加靠近 TCP/IP 的<strong>二进制格式</strong></li><li>而抛弃了 ASCII 码，提升了解析效率</li></ul></li><li>强化安全 <ul><li>HTTP2.0 一般都跑在 HTTPS 上。</li></ul></li><li>多路复用 <ul><li>一个域名只使用一个 TCP 长连接来传输数据</li><li>一个请求对应一个id，这样一个连接上可以有多个请求。</li><li>通过引入<strong>二进制分帧层</strong>，就实现了 HTTP 的多路复用技术</li></ul></li><li>可以设置请求的优先级</li><li>服务器推送</li></ul><h3 id="http-3-0" tabindex="-1">HTTP 3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP 3.0&quot;">​</a></h3><p>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 <strong>TCP 的多路数据流</strong>、<strong>传输可靠性</strong>等功能，我们把这套功能称为 <strong>QUIC 协议</strong>。</p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li><li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.2 有更多的优点，其中最重要的一点是<strong>减少了握手所花费的 RTT 个数</strong>。</li><li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在<strong>同一物理连接上可以有多个独立的逻辑数据流</strong>。实现了数据流的单独传输，就解决了 TCP 中的问题。</li><li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li></ul><h2 id="websocket-协议" tabindex="-1">WebSocket 协议 <a class="header-anchor" href="#websocket-协议" aria-label="Permalink to &quot;WebSocket 协议&quot;">​</a></h2><p>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p><h3 id="websocket连接是如何创建的" tabindex="-1">WebSocket连接是如何创建的 <a class="header-anchor" href="#websocket连接是如何创建的" aria-label="Permalink to &quot;WebSocket连接是如何创建的&quot;">​</a></h3><p>在客户端的使用</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">url</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;ws://localhost:8080/websocket/text&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">ws</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">WebSocket</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">ws.</span><span style="color:#B392F0;">onopen</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;websocket connection open.&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(event);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">ws.</span><span style="color:#B392F0;">onmessage</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;websocket message received.&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(event.data);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">ws.</span><span style="color:#B392F0;">onclose</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;websocket connection close.&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(event.code);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">ws.</span><span style="color:#B392F0;">onerror</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;websocket connection error.&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(event);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">url</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;ws://localhost:8080/websocket/text&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">ws</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">WebSocket</span><span style="color:#24292E;">(url);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">ws.</span><span style="color:#6F42C1;">onopen</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">event</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;websocket connection open.&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(event);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">ws.</span><span style="color:#6F42C1;">onmessage</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">event</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;websocket message received.&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(event.data);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">ws.</span><span style="color:#6F42C1;">onclose</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">event</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;websocket connection close.&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(event.code);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">ws.</span><span style="color:#6F42C1;">onerror</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">event</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;websocket connection error.&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(event);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>链接状态(readyState)</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">readyState</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> socket.readyState;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">readyState</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> socket.readyState;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>返回值</p><table><thead><tr><th>状态代码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>WebSocket.CONNECTING (正在链接中)</td></tr><tr><td>1</td><td>WebSocket.OPEN (已经链接并且可以通讯)</td></tr><tr><td>2</td><td>WebSocket.CLOSING (连接正在关闭)</td></tr><tr><td>3</td><td>WebSocket.CLOSED (连接已关闭或没有链接成功)</td></tr></tbody></table><p>首先，WebSocket 连接必须由浏览器发起，因为<strong>请求协议是一个标准的HTTP请求</strong></p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">+GET ws://localhost:3000/ws/chat HTTP/1.1</span></span>
<span class="line"><span style="color:#e1e4e8;">Host: localhost</span></span>
<span class="line"><span style="color:#e1e4e8;">+Upgrade: websocket</span></span>
<span class="line"><span style="color:#e1e4e8;">+Connection: Upgrade</span></span>
<span class="line"><span style="color:#e1e4e8;">Origin: http://localhost:3000</span></span>
<span class="line"><span style="color:#e1e4e8;">+Sec-WebSocket-Key: client-random-string</span></span>
<span class="line"><span style="color:#e1e4e8;">+Sec-WebSocket-Version: 13</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">+GET ws://localhost:3000/ws/chat HTTP/1.1</span></span>
<span class="line"><span style="color:#24292e;">Host: localhost</span></span>
<span class="line"><span style="color:#24292e;">+Upgrade: websocket</span></span>
<span class="line"><span style="color:#24292e;">+Connection: Upgrade</span></span>
<span class="line"><span style="color:#24292e;">Origin: http://localhost:3000</span></span>
<span class="line"><span style="color:#24292e;">+Sec-WebSocket-Key: client-random-string</span></span>
<span class="line"><span style="color:#24292e;">+Sec-WebSocket-Version: 13</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>该请求和普通的HTTP请求有几点不同：</p><ul><li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li><li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被<strong>转换为WebSocket连接</strong>；</li><li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li><li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li></ul><p>随后，服务器如果接受该请求，就会返回如下响应：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">+HTTP/1.1 101 Switching Protocols</span></span>
<span class="line"><span style="color:#e1e4e8;">+Upgrade: websocket</span></span>
<span class="line"><span style="color:#e1e4e8;">Connection: Upgrade</span></span>
<span class="line"><span style="color:#e1e4e8;">Sec-WebSocket-Accept: server-random-string</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">+HTTP/1.1 101 Switching Protocols</span></span>
<span class="line"><span style="color:#24292e;">+Upgrade: websocket</span></span>
<span class="line"><span style="color:#24292e;">Connection: Upgrade</span></span>
<span class="line"><span style="color:#24292e;">Sec-WebSocket-Accept: server-random-string</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。</p><h3 id="websocket-优点" tabindex="-1">WebSocket 优点 <a class="header-anchor" href="#websocket-优点" aria-label="Permalink to &quot;WebSocket 优点&quot;">​</a></h3><ul><li>较少的控制开销 <ul><li>在连接创建后，服务器和客户端之间交换数据时，<strong>用于协议控制的数据包头部相对较小</strong>。</li></ul></li><li>更强的<strong>实时性</strong><ul><li>由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。</li></ul></li><li>保持连接状态 <ul><li>与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。</li></ul></li><li>更好的二进制支持 <ul><li>WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</li></ul></li><li>可以支持扩展。 <ul><li>WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。</li></ul></li></ul><h2 id="dns协议" tabindex="-1">DNS协议 <a class="header-anchor" href="#dns协议" aria-label="Permalink to &quot;DNS协议&quot;">​</a></h2><blockquote><p>网络世界的地址簿</p></blockquote><h3 id="socket-库提供查询-ip-地址的功能" tabindex="-1">Socket 库提供查询 IP 地址的功能 <a class="header-anchor" href="#socket-库提供查询-ip-地址的功能" aria-label="Permalink to &quot;Socket 库提供查询 IP 地址的功能&quot;">​</a></h3><p>向 DNS 服务器发出查询，并接收服务器返回的响应消息。对于 DNS 服务器，我们的计算机上一定有相应的 <strong>DNS 客户端</strong>，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称<strong>解析器</strong>。</p><blockquote><p>通过 DNS 查询 IP 地址的操作称为域名解析</p></blockquote><p>解析器实际上是一段程序，它包含在操作系统的 Socket 库中。</p><h3 id="解析器向-dns-服务器发出查询" tabindex="-1">解析器向 DNS 服务器发出查询 <a class="header-anchor" href="#解析器向-dns-服务器发出查询" aria-label="Permalink to &quot;解析器向 DNS 服务器发出查询&quot;">​</a></h3><p>调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。响应消息中包含查询到的 IP 地址，解析器会取出 IP 地址，并将其写入浏览器指定的<strong>内存地址</strong>中。接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。</p><blockquote><p>在 Socket 库中，采用 UDP 协议，进行信息的查询。</p></blockquote><h3 id="dns-服务器的工作步骤" tabindex="-1">DNS 服务器的工作步骤 <a class="header-anchor" href="#dns-服务器的工作步骤" aria-label="Permalink to &quot;DNS 服务器的工作步骤&quot;">​</a></h3><p>DNS 服务器的基本工作就是<strong>接收来自客户端的查询消息</strong>，然后<strong>根据消息的内容返回响应</strong>。</p><p>来自客户端的查询消息包含以下 <strong>3 种信息</strong>。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>域名</td><td>服务器、邮件服务器（邮件地址中 @ 后面的部分）的名称</td></tr><tr><td>Class</td><td>Class 的值<strong>永远</strong>是代表互联网的<strong>IN</strong></td></tr><tr><td>记录类型</td><td>表示域名对应<strong>何种类型</strong>的记录，类型为 <strong>A</strong> 时:表示域名对应的是 <strong>IP 地址</strong>，类型为 <strong>MX</strong> 时:表示域名对应的是邮件服务器</td></tr></tbody></table><p><strong>A 是 Address 的缩写</strong> /<strong>MX：Mail eXchange，邮件交换的缩写</strong></p><p>DNS 服务器上<strong>事先保存</strong>有前面这 3 种信息对应的记录数据。</p><p>例如，如果要查询 <code>www.wl.com</code> 这个域名对应的 IP 地址，客 户端会向 DNS 服务器发送包含以下信息的查询消息。</p><table><thead><tr><th>信息</th></tr></thead><tbody><tr><td>域名 = &lt;www.wl.com&gt;</td></tr><tr><td>Class = IN</td></tr><tr><td>记录类型 = A</td></tr></tbody></table><p>然后，DNS 服务器会从<strong>已有的记录</strong>中查找域名、Class 和记录类型<strong>全部匹配</strong>的记录。</p><blockquote><p>DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。</p></blockquote><p>实际上还有很多其他的类型。</p><ul><li>根据 IP 地址<strong>反查域名</strong>的 PTR 类型</li><li>查询域名相关<strong>别名</strong>的 CNAME类型</li><li>查询 DNS 服务器 IP 地址的 NS 类型</li><li>以及查询<strong>域名属性信息</strong>的SOA 类型等</li></ul><h3 id="信息是如何在-dns-服务器上注册" tabindex="-1">信息是如何在 DNS 服务器上注册 <a class="header-anchor" href="#信息是如何在-dns-服务器上注册" aria-label="Permalink to &quot;信息是如何在 DNS 服务器上注册&quot;">​</a></h3><p>首先，DNS 服务器中的所有信息都是<strong>按照域名以分层次的结构</strong>来保存的。DNS 中的域名都是用<strong>句点来分隔</strong>的，比如 &lt;www.wl.com，这里的句点代表了不同层次之间的界限。&gt;</p><p>在域名中，<strong>越靠右的位置表示其层级越高</strong>。</p><p>这种<strong>具有层次结构</strong>的域名信息会注册到 DNS 服务器中，而<strong>每个域</strong>都是作为<strong>一个整体</strong>来处理的。</p><p>于是，<strong>DNS 服务器也具有了像域名一样的层次结构</strong>，每个域的信息都存放在相应层级的 DNS 服务器中。</p><h3 id="寻找相应的-dns-服务器并获取-ip-地址" tabindex="-1">寻找相应的 DNS 服务器并获取 IP 地址 <a class="header-anchor" href="#寻找相应的-dns-服务器并获取-ip-地址" aria-label="Permalink to &quot;寻找相应的 DNS 服务器并获取 IP 地址&quot;">​</a></h3><p>这里的关键在于<strong>如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管</strong>。</p><p>com、cn 这些域（称为顶级域），它们<strong>各自负责</strong>保存下级 DNS 服务器的信息。在互联网中，com 和 cn 的上面还有一级域，称为<strong>根域</strong>。根域不像 com、cn 那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像 &lt;www.wl.com&gt;. 这样在域名的<strong>最后再加上一个句点</strong>，而这个最后的句点就代表根域。</p><blockquote><p>根域的 DNS 服务器中保管着 com、cn 等的 DNS 服务器的信息</p></blockquote><p>除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中<strong>所有</strong>的 DNS 服务器中。客户端只要能够找到任意一台DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>分配给根域 DNS 服务器的 IP 地址在全世界<strong>仅有 13 个</strong> ，而且这些地址几乎不发生变化。</p><p>DNS 解析流程：</p><p>1.电脑客户端会发出一个 DNS 请求，问 &lt;www.wl.com&gt; 的 IP 是啥啊，并发给本地域名服务器 (<strong>本地 DNS</strong>)。</p><p>2.<strong>本地 DNS</strong> 收到来自客户端的请求。然后，查找对应的记录信息。</p><ul><li>如果能找到 &lt;www.wl.com，它直接就返回&gt; IP 地址。</li><li>如果没有，本地 DNS 会去问它的<strong>根域名服务器</strong>。 3.<strong>根 DNS</strong> 收到来自本地 DNS 的请求，发现后缀是 .com，说：“www.wl.com 啊，这个域名是由.com 区域管理，我给你它的<strong>顶级域名服务器的地址</strong>，你去问问它吧。”</li></ul><p>4.<strong>本地 DNS</strong> 转向问顶级域名服务器：</p><ul><li>顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些<strong>一级域名</strong></li><li>它<strong>负责管理二级域名</strong>，比如 wl.com，所以它能提供一条更清晰的方向 5.<strong>顶级域名服务器</strong>说：“我给你负责 &lt;www.wl.com&gt; 区域的<strong>权威 DNS 服务器</strong>的地址，你去问它应该能问到。”</li></ul><p>6.<strong>本地 DNS</strong> 转向问<strong>权威 DNS 服务器</strong>：“www.wl.com 对应的 IP 是啥呀？”</p><ul><li>wl.com 的权威 DNS 服务器，它是域名解析结果的原出处。</li><li>为啥叫权威呢？就是我的域名我做主。 7.<strong>权威 DNS 服务器</strong>查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li></ul><p>8.本地 DNS 再将 IP 地址<strong>返回客户端</strong>，客户端和目标建立连接。</p><p>通过缓存加快 DNS 服务器的响应：</p><p>如果要查询的域名和相关信息<strong>已经在缓存</strong>中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。</p><p>这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会<strong>发生改变</strong>，这时缓存中的信息就有可能是不正确的。因此，DNS 服务器中保存的信息都设置有一个<strong>有效期</strong>，当缓存中的信息超过有效期后，数据就会从缓存中删除。</p><h3 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h3><p>内部负载均衡：<br> 例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是<strong>一对一</strong>的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要<strong>配置成为域名</strong>就可以了。在域名解析的时候，我们只要<strong>配置策略</strong>，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p><p>全局负载均衡：<br> 为了保证我们的应用<strong>高可用</strong>，往往会部署在多个机房，<strong>每个地方都会有自己的 IP 地址</strong>。当用户访问某个域名的时候，这个 IP 地址可以<strong>轮询访问多个数据中心</strong>。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用</p><h2 id="tcp-协议" tabindex="-1">TCP 协议 <a class="header-anchor" href="#tcp-协议" aria-label="Permalink to &quot;TCP 协议&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>字段解析：</p><ul><li>源端口号 Source Port / 目标端口号 Destination Port: <ul><li>用于区别主机中的<strong>不同进程</strong></li><li>IP地址是用来区分不同的主机的</li><li>源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li></ul></li><li>分包序号Sequence Number: <ul><li>应用程序数据如果 大于 最大分段大小Maximum Segment Size(MSS)就得要进行分段。</li><li>这个 Sequence Number 就是记录每个封包的序号，可以让 server 重新将 TCP 的数据组合起来。</li><li>主要用来<strong>解决网络报乱序</strong>的问题</li></ul></li><li>回应序号Acknowledge Number: <ul><li>为了确认<strong>发送端</strong>确实有收到<strong>接收端</strong>所送出的封包数据。</li><li>当 <strong>接收端</strong>收到这个确认码时，就能够确定<strong>之前传递的封包已经被正确的收下</strong>了。</li><li>回应序号应当是<strong>上次已成功收到分包序号加1</strong>。</li><li>用来<strong>解决不丢包</strong>的问题 -<strong>Code</strong>（控制标识码Control Flag）</li><li>这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动 （只介绍常用的） -<strong>SYN</strong>：若为 1，表示 client 希望双方建立<strong>同步处理</strong> -<strong>ACK</strong>：若为 1 代表这个封包为<strong>响应封包</strong> -<strong>FIN</strong>：若为 1 ，表示<strong>传送结束</strong>，所以通知对方数据传毕， 是否同意断线，只是发送者还在等待对方的响应而已</li></ul></li></ul><hr><p>1.<strong>SYN</strong></p><ul><li>客户端选择一个<strong>随机序列号</strong> x，并发送一个 SYN 分组</li></ul><p>2.<strong>SYN + ACK</strong></p><ul><li>y</li><li>x + 1</li><li>服务器给 <strong>x 加 1</strong></li><li>并选择自己的一个<strong>随机序列号</strong></li><li>然后返回响应</li></ul><p>3.<strong>ACK</strong></p><ul><li>x + 1</li><li>y + 1</li><li>客户端<strong>给 x 和 y 加 1</strong></li><li>并发送握手期间的最后一个 ACK 分组</li></ul><p>三次握手完成后，客户端与服务器之间就可以通信了。客户端可以在发送 ACK 分组之后<strong>立即发送数据</strong>，而服务器必须等接收到 ACK 分组之后才能发送数据。</p><h3 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to &quot;滑动窗口&quot;">​</a></h3><p>TCP 采用<strong>滑动窗口</strong>来管理数据发送和 ACK 号的操作。</p><blockquote><p>所谓<strong>滑动窗口</strong>，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。</p></blockquote><p>通过这种方式，就可以实现同一时间发送多个包，减少网络延迟。其实，通过窗口，TCP 可以控制双向发送数据的<strong>速度</strong>。</p><h4 id="流量控制" tabindex="-1">流量控制 <a class="header-anchor" href="#流量控制" aria-label="Permalink to &quot;流量控制&quot;">​</a></h4><blockquote><p>流量控制是一种<strong>预防发送端过多向接收端发送数据</strong>的机制。</p></blockquote><p>为实现流量控制，TCP 连接的每一方都要通告自己的<strong>接收窗口</strong>（rwnd），其中包含能够保存数据的<strong>缓冲区空间大小信息</strong>。</p><p><strong>第一次</strong>建立连接时，两端都会使用自身系统的<strong>默认设置</strong>来发送 rwnd。在后面的数据交换过程中，<strong>每个 ACK 分组</strong>都会携带相应的<strong>最新 rwnd 值</strong>，以便两端<strong>动态调整数据流速</strong>，使之适应发送端和接收端的容量及处理能力。</p><h4 id="慢启动-利用可用宽带" tabindex="-1">慢启动 (利用可用宽带) <a class="header-anchor" href="#慢启动-利用可用宽带" aria-label="Permalink to &quot;慢启动 (利用可用宽带)&quot;">​</a></h4><p>流量控制确实可以<strong>防止发送端向接收端过多发送数据</strong>，但却没有机制预防<strong>任何一端</strong>向潜在网络<strong>过多发送数据</strong>。换句话说，发送端和接收端在<strong>连接建立之初</strong>，谁也不知道<strong>可用带宽</strong>是多少。因此需要一个<strong>估算机制</strong>，然后还要根据网络中不断变化的条件而<strong>动态改变速度</strong>。</p><p><strong>拥塞窗口大小</strong>（cwnd）:发送端对从<strong>客户端</strong>接收确认（ACK）<strong>之前</strong>可以发送数据量的限制。发送端不会通告 cwnd 变量，即<strong>发送端和接收端不会交换这个值</strong>。</p><p>服务器和客户端怎么确定拥塞窗口大小的最优值呢:解决方案就是<strong>慢启动</strong>:即在分组被确认后增大窗口大小，<strong>慢慢地启动</strong>。</p><p>无论带宽多大，每个 TCP 连接都<strong>必须经过慢启动阶段</strong>，换句话说，应用<strong>不可能一上来就完全利用连接的最大带宽</strong>，把<strong>初始拥塞窗口大小</strong>增加到一个合理值，可以减少客户端与服务器之间的往返时间。</p><h3 id="tcp-队首阻塞" tabindex="-1">TCP 队首阻塞 <a class="header-anchor" href="#tcp-队首阻塞" aria-label="Permalink to &quot;TCP 队首阻塞&quot;">​</a></h3><blockquote><p>TCP 在<strong>不可靠的信道</strong>上实现了<strong>可靠的网络传输</strong></p></blockquote><p>每个 TCP 分组都会带着一个<strong>唯一的序列号</strong>被发出，而所有分组<strong>必须按顺序</strong>传送到接收端。如果中途有一个分组没能到达接收端，那么后续分组必须<strong>保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端</strong>。这<strong>一切</strong>都发生在 TCP 层，<strong>应用程序</strong>对 TCP 重发和缓冲区中排队的分组<strong>一无所知</strong>，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到<strong>延迟交付</strong>。这种效应称为TCP 队首阻塞Head of Line Blocking(HOL)</p><p>队首阻塞造成的延迟可以让我们的应用程序不用关心<strong>分组重排和重组</strong>，分组到达时间会存在<strong>无法预知的延迟变化</strong>。这个时间变化通常被称为<strong>抖动</strong>，也是影响应用程序性能的一个主要因素。</p><blockquote><p><strong>TCP 队首阻塞</strong>造成的延迟,也是影响应用程序性能的一个主要因素</p></blockquote><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>1.<strong>FIN</strong></p><ul><li>客户端选择一个<strong>随机序列号</strong> x，并发送一个 FIN 分组</li></ul><p>2.<strong>ACK</strong></p><ul><li>x + 1</li><li>服务器给 <strong>x 加 1</strong></li></ul><p>3.等后端数据都传输完毕后。。。。。 4.<strong>FIN</strong></p><ul><li>y</li><li>服务器选择自己的一个<strong>随机序列号</strong></li></ul><p>5.<strong>ACK</strong></p><ul><li>x + 1</li><li>y + 1</li><li>客户端<strong>给 x 和 y 加 1</strong></li><li>并发送握手期间的最后一个 ACK 分组</li></ul><p>注意点：</p><ul><li>相比三次握手，四次挥手，在 server 发起的时候，是将<strong>控制标志码</strong>由 SYN 换成 FIN。</li><li>可以看到，在<strong>第二次挥手和第三次挥手中间</strong>，有很多未发送完成的数据，其实也好理解，在 client 接收到 server 传入的 FIN 包时候，此时可能正处于某些大包数据的发送阶段，如果此时<strong>直接回复</strong> 发送端的断开操作。并且，如果 server FIN 包早于其他正常数据包到达 client。那这些本应该被 client 收录的数据，就会<strong>平白无故的丢失</strong>。</li></ul><p>为什么要四次挥手</p><blockquote><p>TCP协议是一种<strong>面向连接</strong>的、<strong>可靠</strong>的、<strong>基于字节流</strong>的传输层通信协议。</p></blockquote><p>TCP是<strong>全双工模式</strong>，这就意味着</p><ul><li>当主机1发出FIN报文段时，只是表示主机1已经<strong>没有数据要发送</strong>了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是<strong>可以接受来自主机2的数据</strong></li><li>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的</li><li>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接</li></ul>`,223),t=[e];function p(r,i,c,g,d,u){return n(),l("div",null,t)}const b=s(o,[["render",p]]);export{E as __pageData,b as default};
