import{_ as e,o,c as a,Q as i}from"./chunks/framework.aea2adc8.js";const m=JSON.parse('{"title":"复习","description":"","frontmatter":{},"headers":[],"relativePath":"guide/frame/git/review.md","filePath":"guide/frame/git/review.md","lastUpdated":1710047191000}'),t={name:"guide/frame/git/review.md"},r=i('<h1 id="复习" tabindex="-1">复习 <a class="header-anchor" href="#复习" aria-label="Permalink to &quot;复习&quot;">​</a></h1><h2 id="说说版本管理的理解-常用的版本管理工具有哪些" tabindex="-1">说说版本管理的理解？常用的版本管理工具有哪些？ <a class="header-anchor" href="#说说版本管理的理解-常用的版本管理工具有哪些" aria-label="Permalink to &quot;说说版本管理的理解？常用的版本管理工具有哪些？&quot;">​</a></h2><p>版本管理，亦称为源代码控制，是一种在软件开发中用来管理整个开发过程中源代码的变更的技术。它允许开发者在开发过程中记录和跟踪代码的每一次变更，以便随时回溯到之前的版本，同时也支持多人协作开发，帮助解决代码合并时可能出现的冲突问题。版本管理的核心在于保持项目历史的完整性，确保团队成员可以并行工作而不会相互干扰，以及能够快速定位并修复开发过程中出现的问题。</p><h3 id="git" tabindex="-1">Git <a class="header-anchor" href="#git" aria-label="Permalink to &quot;Git&quot;">​</a></h3><p>Git 是目前最流行的分布式版本控制系统，由 Linux 的创始人 Linus Torvalds 开发。它具有高效的性能，支持非线性开发策略，允许多个并行的分支，便于合并和重组。Git 的特点是允许本地分布式工作，即每个开发者的电脑上都是一个完整的仓库，能够独立进行版本控制操作。</p><h3 id="subversion-svn" tabindex="-1">Subversion (SVN) <a class="header-anchor" href="#subversion-svn" aria-label="Permalink to &quot;Subversion (SVN)&quot;">​</a></h3><p>Subversion（简称SVN）是一个集中式版本控制系统，与 Git 相比，所有的版本控制操作都是基于网络的中心仓库完成的。它支持文件的版本控制，可以记录每次文件的改动，同时保留文件的修改时间和修改人信息。SVN适合于中小型项目的版本管理。</p><h3 id="mercurial" tabindex="-1">Mercurial <a class="header-anchor" href="#mercurial" aria-label="Permalink to &quot;Mercurial&quot;">​</a></h3><p>Mercurial 也是一种分布式版本控制工具，与 Git 类似，但它在命令和操作的简化上更加注重用户体验。Mercurial 设计简洁，易于学习，提供了高效的数据处理机制，使得大规模的代码库管理变得更加高效。</p><h3 id="cvs" tabindex="-1">CVS <a class="header-anchor" href="#cvs" aria-label="Permalink to &quot;CVS&quot;">​</a></h3><p>CVS（Concurrent Versions System）是一种较老的项目版本控制系统，它支持开发者对项目文件进行版本管理和跟踪。虽然它的功能比较基础，但在很长一段时间内，CVS 都是版本控制的标准选择。随着 Git 和 SVN 等现代化工具的出现，CVS 的使用已经大幅度减少。</p><p>总体而言，版本管理工具是软件开发过程中不可或缺的一部分，不同的工具各有优势，开发团队应根据自己的具体需求和偏好选择最合适的版本管理工具。</p><h2 id="说说git的理解" tabindex="-1">说说Git的理解？ <a class="header-anchor" href="#说说git的理解" aria-label="Permalink to &quot;说说Git的理解？&quot;">​</a></h2><p>Git 是一个开源的分布式版本控制系统，用于高效地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了更好地管理 Linux 内核开发而创立的。Git 以其高速、灵活、对分布式非线性工作流的支持等特点，在开发社区中极为流行。</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><h4 id="分布式版本控制" tabindex="-1">分布式版本控制 <a class="header-anchor" href="#分布式版本控制" aria-label="Permalink to &quot;分布式版本控制&quot;">​</a></h4><p>与集中式版本控制系统不同，Git 在每个开发者的本地都创建了完整的仓库副本，包括代码的历史记录。这意味着即使在离线状态下，开发者也可以进行提交、分支、合并等操作，提高了效率和灵活性。</p><h4 id="数据完整性" tabindex="-1">数据完整性 <a class="header-anchor" href="#数据完整性" aria-label="Permalink to &quot;数据完整性&quot;">​</a></h4><p>Git 通过SHA-1哈希算法保证项目历史的完整性和一致性。每次提交都会生成一个独一无二的哈希值，确保代码历史不被篡改。</p><h4 id="高效的性能" tabindex="-1">高效的性能 <a class="header-anchor" href="#高效的性能" aria-label="Permalink to &quot;高效的性能&quot;">​</a></h4><p>Git 设计之初就考虑到了性能。无论是本地操作还是与远程仓库的通信，Git 的操作都极为高效。例如，Git 的分支操作几乎是瞬时完成的，这使得开发者可以灵活地使用分支来管理功能开发、修复等。</p><h4 id="支持非线性开发" tabindex="-1">支持非线性开发 <a class="header-anchor" href="#支持非线性开发" aria-label="Permalink to &quot;支持非线性开发&quot;">​</a></h4><p>Git 强大的分支管理能力支持非线性开发流程，允许创建、合并和删除分支。这意味着多个开发者可以同时在不同的功能上工作，之后再将这些功能合并到主分支上。</p><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><h4 id="分支-branch" tabindex="-1">分支 (Branch) <a class="header-anchor" href="#分支-branch" aria-label="Permalink to &quot;分支 (Branch)&quot;">​</a></h4><p>Git 的一个核心概念是分支，它使得同时进行多个功能的开发和修复成为可能。Git 的分支操作非常轻量级，鼓励开发者频繁地使用分支。</p><h4 id="提交-commit" tabindex="-1">提交 (Commit) <a class="header-anchor" href="#提交-commit" aria-label="Permalink to &quot;提交 (Commit)&quot;">​</a></h4><p>提交是 Git 中的一个基本操作，它会将当前工作区的状态保存到本地仓库的历史中。每次提交都会生成一个独一无二的哈希值，代表这次提交的快照。</p><h4 id="合并-merge" tabindex="-1">合并 (Merge) <a class="header-anchor" href="#合并-merge" aria-label="Permalink to &quot;合并 (Merge)&quot;">​</a></h4><p>合并是将不同分支的改动合并到一起的过程。Git 支持多种合并策略，以处理不同的合并场景，如快进合并、三方合并等。</p><h4 id="冲突-conflict" tabindex="-1">冲突 (Conflict) <a class="header-anchor" href="#冲突-conflict" aria-label="Permalink to &quot;冲突 (Conflict)&quot;">​</a></h4><p>在合并分支时，如果不同分支对同一文件的同一部分进行了不同的修改，就会发生冲突。Git 会标记这些冲突，需要开发者手动解决后才能继续合并操作。</p><h3 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h3><ul><li><code>git clone</code>：克隆远程仓库到本地。</li><li><code>git add</code>：将文件添加到暂存区。</li><li><code>git commit</code>：将暂存区的改动提交到本地仓库。</li><li><code>git push</code>：将本地仓库的改动推送到远程仓库。</li><li><code>git pull</code>：从远程仓库拉取最新的改动。</li><li><code>git branch</code>：列出、创建或删除分支。</li><li><code>git checkout</code>：切换分支或恢复工作区文件。</li><li><code>git merge</code>：将两个分支的改动合并到一起。</li></ul><p>Git 的设计哲学是以简化开发者的工作流程为目的，其功能强大且灵活，可以适应各种项目和团队的需求。</p><h2 id="说说git中-fork-clone-branch这三个概念-有什么区别" tabindex="-1">说说Git中 fork, clone,branch这三个概念，有什么区别? <a class="header-anchor" href="#说说git中-fork-clone-branch这三个概念-有什么区别" aria-label="Permalink to &quot;说说Git中 fork, clone,branch这三个概念，有什么区别?&quot;">​</a></h2><p>Git 是一个分布式版本控制系统，广泛应用于软件开发中，以支持代码的多人协作和版本管理。在 Git 的使用过程中，<code>fork</code>、<code>clone</code> 和 <code>branch</code> 是三个常用且基本的操作，它们在协作开发过程中扮演着不同的角色。</p><h3 id="fork" tabindex="-1">fork <a class="header-anchor" href="#fork" aria-label="Permalink to &quot;fork&quot;">​</a></h3><p><code>fork</code> 是在远程仓库层面进行的操作，意味着你创建了原有仓库（通常是别人的项目）的一个完整副本，并将这个副本放置到你的 GitHub 账号下。这样，你就可以在这个副本上自由地进行改动，而不会影响原始仓库。<code>fork</code> 常用于对开源项目的贡献，你可以在自己的 <code>fork</code> 副本上进行修改，然后通过 Pull Request 向原仓库贡献代码。</p><h3 id="clone" tabindex="-1">clone <a class="header-anchor" href="#clone" aria-label="Permalink to &quot;clone&quot;">​</a></h3><p><code>clone</code> 是指将远程仓库的内容复制一份到本地，创建一个一模一样的仓库副本，包含所有的文件、代码历史和分支。通过 <code>clone</code> 操作，你可以在本地机器上工作，做出更改，并通过 git 命令将更改推送回远程仓库。<code>clone</code> 是协作开发中开始工作的第一步，无论是直接对原仓库还是 <code>fork</code> 的仓库进行 <code>clone</code>。</p><h3 id="branch" tabindex="-1">branch <a class="header-anchor" href="#branch" aria-label="Permalink to &quot;branch&quot;">​</a></h3><p><code>branch</code> 在 Git 中是用来隔离不同工作内容的机制，它允许你在不同的分支上独立进行开发，而不影响主分支（通常是 <code>master</code> 或 <code>main</code> 分支）。分支可以用来开发新功能、修复 bugs 或进行实验，开发完成后，可以通过合并（merge）操作将分支的更改集成回主分支。与 <code>fork</code> 和 <code>clone</code> 不同，<code>branch</code> 主要用于版本控制和功能开发的隔离。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li><strong>层面上</strong>：<code>fork</code> 是在远程仓库层面进行的，它创建了仓库的一个独立副本；<code>clone</code> 是将远程仓库复制到本地环境，以便开发和测试；而 <code>branch</code> 是在已有的仓库（无论是本地仓库还是 <code>clone</code> 后的本地仓库）中，用于隔离不同的开发任务。</li><li><strong>目的上</strong>：<code>fork</code> 用于在原项目的基础上进行独立的开发或为原项目贡献代码；<code>clone</code> 用于获取远程仓库的本地副本，以便进行开发或者分析项目代码；<code>branch</code> 用于在单个项目内部管理不同的开发线路或功能，确保不同功能的开发互不影响。</li></ul><p>综上所述，<code>fork</code>、<code>clone</code> 和 <code>branch</code> 在协作开发和版本控制中各司其职，理解它们的不同可以帮助更高效地使用 Git 进行团队协作和项目管理。</p><h2 id="说说git常用的命令有哪些" tabindex="-1">说说Git常用的命令有哪些？ <a class="header-anchor" href="#说说git常用的命令有哪些" aria-label="Permalink to &quot;说说Git常用的命令有哪些？&quot;">​</a></h2><p>Git 作为当前最流行的分布式版本控制系统，拥有一系列强大的功能来支持软件开发的过程。以下是一些 Git 中常用的命令，它们涵盖了版本控制的基本操作，如版本提交、分支管理、代码合并等。</p><h3 id="基础命令" tabindex="-1">基础命令 <a class="header-anchor" href="#基础命令" aria-label="Permalink to &quot;基础命令&quot;">​</a></h3><ul><li><code>git init</code>: 初始化一个新的 Git 仓库。</li><li><code>git clone [url]</code>: 克隆（下载）一个项目和它的整个代码历史。</li><li><code>git add [file]</code>: 添加指定文件到暂存区。</li><li><code>git add .</code>: 添加当前目录下的所有更改到暂存区。</li><li><code>git commit -m &quot;[commit message]&quot;</code>: 提交暂存区到仓库区。</li><li><code>git status</code>: 显示有变更的文件。</li><li><code>git config --global user.name &quot;[name]&quot;</code>: 配置用户名称。</li><li><code>git config --global user.email &quot;[email address]&quot;</code>: 配置用户邮箱。</li></ul><h3 id="分支管理" tabindex="-1">分支管理 <a class="header-anchor" href="#分支管理" aria-label="Permalink to &quot;分支管理&quot;">​</a></h3><ul><li><code>git branch</code>: 列出所有本地分支。</li><li><code>git branch [branch_name]</code>: 创建新分支。</li><li><code>git checkout [branch_name]</code>: 切换到指定分支并更新工作区。</li><li><code>git merge [branch]</code>: 合并指定分支到当前分支。</li><li><code>git branch -d [branch_name]</code>: 删除分支。</li></ul><h3 id="远程操作" tabindex="-1">远程操作 <a class="header-anchor" href="#远程操作" aria-label="Permalink to &quot;远程操作&quot;">​</a></h3><ul><li><code>git push [alias] [branch]</code>: 将代码推送到远程仓库的指定分支。</li><li><code>git clone [url]</code>: 从远程仓库克隆。</li><li><code>git pull [alias] [branch]</code>: 更新远程仓库到本地。</li><li><code>git remote add [alias] [url]</code>: 添加远程仓库地址。</li><li><code>git fetch [alias]</code>: 从远程仓库下载新分支与数据。</li></ul><h3 id="查看历史" tabindex="-1">查看历史 <a class="header-anchor" href="#查看历史" aria-label="Permalink to &quot;查看历史&quot;">​</a></h3><ul><li><code>git log</code>: 查看历史提交记录。</li><li><code>git log --oneline</code>: 查看简洁的历史提交记录。</li><li><code>git diff</code>: 查看未暂存的文件更新了哪些部分。</li><li><code>git diff --staged</code>: 查看已暂存的将要提交的内容的差异。</li></ul><h3 id="撤销操作" tabindex="-1">撤销操作 <a class="header-anchor" href="#撤销操作" aria-label="Permalink to &quot;撤销操作&quot;">​</a></h3><ul><li><code>git checkout -- [file]</code>: 撤销对文件的修改（使之回到最近一次 git commit 或 git add 的状态）。</li><li><code>git reset [file]</code>: 从暂存区移除文件，但保留文件当前的内容。</li><li><code>git reset --hard [commit]</code>: 撤销到指定的提交，该提交之后的所有变更将丢失。</li></ul><h3 id="其他命令" tabindex="-1">其他命令 <a class="header-anchor" href="#其他命令" aria-label="Permalink to &quot;其他命令&quot;">​</a></h3><ul><li><code>git stash</code>: 暂时将未提交的变化存储起来，以便清理工作区。</li><li><code>git stash pop</code>: 应用存储起来的最近一次改动。</li></ul><p>这些命令构成了 Git 操作的基础，通过它们可以完成大部分的版本控制任务。熟练掌握这些命令对于前端开发工程师来说是非常重要的，因为它们将被频繁地使用在日常的开发工作中。</p><h2 id="说说git-中-head、工作树和索引之间的区别" tabindex="-1">说说Git 中 HEAD、工作树和索引之间的区别？ <a class="header-anchor" href="#说说git-中-head、工作树和索引之间的区别" aria-label="Permalink to &quot;说说Git 中 HEAD、工作树和索引之间的区别？&quot;">​</a></h2><p>在 Git 中，<code>HEAD</code>、工作树（Working Tree）和索引（Index）是管理和操作项目代码的重要概念。理解它们之间的区别对于有效地使用 Git 来说是非常关键的。</p><h3 id="head" tabindex="-1">HEAD <a class="header-anchor" href="#head" aria-label="Permalink to &quot;HEAD&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>HEAD</code> 是一个引用（reference），指向当前所在分支的最后一次提交（commit）。它是一个指针，用来表示当前的工作环境状态。</li><li><strong>作用</strong>：通过移动 <code>HEAD</code> 指针，可以改变当前查看和工作的基点，常见的操作包括切换分支或回退到某个特定的提交。</li><li><strong>示例</strong>：当执行 <code>git checkout</code> 命令切换分支时，<code>HEAD</code> 指针就会更新，指向新分支的最新提交。</li></ul><h3 id="工作树-working-tree" tabindex="-1">工作树（Working Tree） <a class="header-anchor" href="#工作树-working-tree" aria-label="Permalink to &quot;工作树（Working Tree）&quot;">​</a></h3><ul><li><strong>定义</strong>：工作树，又称工作目录，是项目的一个工作副本。这里包含了当前分支上所有的文件和目录，它们是用户可以看到和编辑的。</li><li><strong>作用</strong>：工作树让用户可以查看或修改文件。当修改文件后，这些更改只存在于工作树中，尚未被 Git 追踪保存。</li><li><strong>示例</strong>：当你编辑任何项目文件时，这个文件就在工作树中被修改了。这些修改需要通过 <code>git add</code> 添加到索引中，之后通过 <code>git commit</code> 提交到仓库中。</li></ul><h3 id="索引-index" tabindex="-1">索引（Index） <a class="header-anchor" href="#索引-index" aria-label="Permalink to &quot;索引（Index）&quot;">​</a></h3><ul><li><strong>定义</strong>：索引，又称暂存区，是一个准备好下次提交的文件列表。它是工作树和仓库（Repository）之间的中间层，用于收集和准备要被提交的更改。</li><li><strong>作用</strong>：当执行 <code>git add</code> 命令时，对文件的更改被添加到索引中。这允许开发者在实际提交之前，有选择性地控制哪些修改应该被包含在下一次提交中，以便可以构建干净、有意义的提交。</li><li><strong>示例</strong>：你可能对多个文件做了修改，但只想提交其中的一部分更改。这时，你可以使用 <code>git add [file]</code> 将指定文件的更改添加到索引中，然后使用 <code>git commit</code> 提交这些更改，而不影响其他未添加到索引的文件更改。</li></ul><h3 id="三者之间的关系和区别" tabindex="-1">三者之间的关系和区别 <a class="header-anchor" href="#三者之间的关系和区别" aria-label="Permalink to &quot;三者之间的关系和区别&quot;">​</a></h3><ul><li><strong>HEAD 与工作树</strong>：<code>HEAD</code> 指向当前分支的最新提交，代表了 Git 仓库的最新快照。而工作树包含了这一快照的实际文件，允许用户查看和修改。<code>HEAD</code> 和工作树之间的区别在于，<code>HEAD</code> 是指向历史提交的指针，而工作树是这些提交内容的实时表示。</li><li><strong>工作树与索引</strong>：工作树是用户进行工作的地方，包含当前分支上的文件和目录。当在工作树中修改文件后，这些修改需要被添加到索引中，以便它们可以被下一次提交捕捉。索引充当了工作树和最终提交之间的缓冲区，允许开发者构建提交并最终将其保存到 Git 仓库的历史记录中。</li><li><strong>HEAD 与索引</strong>：<code>HEAD</code> 直接关联到 Git 历史中的特定提交，而索引则是即将成为历史的一部分的更改的集合。当执行 <code>git commit</code> 命令时，索引中的更改会形成一个新的提交，这个提交会成为 <code>HEAD</code> 指向的对象。</li></ul><p>理解 <code>HEAD</code>、工作树和索引之间的区别和关系，对于有效地使用 Git 控制版本和协作开发至关重要。这些概念帮助定义了 Git 工作流程的不同阶段，从更改的制作和选择（工作树和索引），到更改的记录（通过提交到仓库）。</p><h2 id="说说-git-pull-和-git-fetch-的理解-有什么区别" tabindex="-1">说说 git pull 和 git fetch 的理解？有什么区别？ <a class="header-anchor" href="#说说-git-pull-和-git-fetch-的理解-有什么区别" aria-label="Permalink to &quot;说说 git pull 和 git fetch 的理解？有什么区别？&quot;">​</a></h2><p>在 Git 版本控制系统中，<code>git pull</code> 和 <code>git fetch</code> 是两个常用命令，用于同步本地仓库与远程仓库之间的内容。它们之间的主要区别在于对本地代码和本地分支的影响程度。</p><h3 id="git-fetch" tabindex="-1">git fetch <a class="header-anchor" href="#git-fetch" aria-label="Permalink to &quot;git fetch&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git fetch</code> 命令用于从远程仓库下载最新的内容，但不会自动合并或修改你当前的工作。它会获取远程仓库的所有分支和标签，更新你的本地仓库与远程仓库的差异数据。</li><li><strong>作用</strong>：该命令主要用于查看远程仓库中的变化，而不直接影响你的本地工作环境。<code>git fetch</code> 命令执行后，你可以使用 <code>git log</code> 或其他工具查看新拉取的提交历史。</li><li><strong>示例</strong>：执行 <code>git fetch origin</code> 会从名为 <code>origin</code> 的远程仓库获取最新的更改，但不会合并到你的当前分支或修改你的文件。</li></ul><h3 id="git-pull" tabindex="-1">git pull <a class="header-anchor" href="#git-pull" aria-label="Permalink to &quot;git pull&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git pull</code> 命令实际上是 <code>git fetch</code> 命令之后紧跟一个 <code>git merge FETCH_HEAD</code> 的快捷方式。它从远程仓库获取最新的版本，并将获取的数据合并到本地分支，自动合并远程分支到当前分支。</li><li><strong>作用</strong>：该命令用于将远程仓库的更改合并到当前分支中，更新你的本地仓库以反映远程仓库的内容。如果有必要，它会自动启动合并操作。</li><li><strong>示例</strong>：执行 <code>git pull origin master</code> 会从 <code>origin</code> 远程仓库的 <code>master</code> 分支获取最新的更改，并尝试合并这些更改到当前分支。</li></ul><h3 id="区别-1" tabindex="-1">区别 <a class="header-anchor" href="#区别-1" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li><strong>自动合并</strong>：<code>git pull</code> 会自动将远程分支的更改合并到当前分支，而 <code>git fetch</code> 只是下载这些更改，不会自动合并。</li><li><strong>安全性</strong>：由于 <code>git fetch</code> 不自动合并更改，它被认为是一种更安全的方式来查看和审查远程更改之前的操作。你可以先<code>fetch</code>变更，审查它们，然后手动执行合并。</li><li><strong>使用场景</strong>：如果你想保持本地仓库更新且立即反映远程仓库的状态，使用 <code>git pull</code> 是更直接的方法。如果你需要更多地控制合并的过程或在合并前审查更改，那么先使用 <code>git fetch</code> 后手动合并可能是更好的选择。</li></ul><p>总结来说，<code>git fetch</code> 和 <code>git pull</code> 都是同步远程仓库更改到本地仓库的命令，但它们在自动合并远程更改方面有所不同。理解这两个命令的差异可以帮助开发者更有效地管理和同步代码。</p><h2 id="说说-git-stash-的理解-应用场景" tabindex="-1">说说 git stash 的理解？应用场景？ <a class="header-anchor" href="#说说-git-stash-的理解-应用场景" aria-label="Permalink to &quot;说说 git stash 的理解？应用场景？&quot;">​</a></h2><p><code>git stash</code> 是 Git 提供的一个强大的功能，允许开发者临时保存当前工作目录和索引（暂存区）的修改，以便可以在一个干净的工作状态下进行其他任务，而后再恢复之前保存的工作状态。这是通过将工作目录和索引的当前更改存储在一个地方，而不是提交这些更改到分支中来实现的。</p><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><h4 id="临时切换分支" tabindex="-1">临时切换分支 <a class="header-anchor" href="#临时切换分支" aria-label="Permalink to &quot;临时切换分支&quot;">​</a></h4><p>当你正在一个分支上工作，但需要临时切换到另一个分支处理一些紧急的任务时，你可能不想提交一个未完成的功能。这时，<code>git stash</code> 可以帮助你保存当前的工作进度，让你可以安心切换分支而不丢失任何进度。</p><h4 id="保持工作目录的清洁" tabindex="-1">保持工作目录的清洁 <a class="header-anchor" href="#保持工作目录的清洁" aria-label="Permalink to &quot;保持工作目录的清洁&quot;">​</a></h4><p>有时候，你可能想要实验一些新的想法，但又不确定这些更改是否会被保留。使用 <code>git stash</code> 可以帮助你保存当前的更改，保持工作目录的清洁，然后自由地尝试新的想法。</p><h4 id="合并冲突时" tabindex="-1">合并冲突时 <a class="header-anchor" href="#合并冲突时" aria-label="Permalink to &quot;合并冲突时&quot;">​</a></h4><p>在执行 <code>git pull</code> 或 <code>git merge</code> 时，如果遇到合并冲突，而你当前有未提交的更改，你可以使用 <code>git stash</code> 来保存这些更改，解决冲突后再恢复你的工作状态。</p><h3 id="常用命令-1" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令-1" aria-label="Permalink to &quot;常用命令&quot;">​</a></h3><ul><li><code>git stash</code>: 保存当前的工作进度。它会将暂存区和工作目录的更改保存起来。</li><li><code>git stash list</code>: 查看所有的 stash 项。每个 stash 项都是工作目录和索引的一个快照。</li><li><code>git stash apply</code>: 恢复最近一次的 stash。默认情况下，它不会删除 stash 项，需要使用 <code>git stash drop</code> 手动删除。</li><li><code>git stash pop</code>: 恢复最近一次的 stash，并删除这个 stash 项。</li><li><code>git stash drop</code>: 删除一个 stash 项。如果不指定 stash 项，默认删除最近的 stash。</li><li><code>git stash clear</code>: 删除所有的 stash 项。</li></ul><p>总结来说，<code>git stash</code> 是一个非常有用的工具，用于临时保存和恢复工作目录的状态，它让开发者能够在一个干净的工作状态下切换任务，提高了工作的灵活性和效率。</p><h2 id="说说-git-rebase-和-git-merge-的理解-区别" tabindex="-1">说说 git rebase 和 git merge 的理解？区别？ <a class="header-anchor" href="#说说-git-rebase-和-git-merge-的理解-区别" aria-label="Permalink to &quot;说说 git rebase 和 git merge 的理解？区别？&quot;">​</a></h2><p>在 Git 中，<code>git rebase</code> 和 <code>git merge</code> 都是用来整合来自不同分支的更改的命令。它们的目的是相同的，即将多个分支的工作合并成一个线性的工作流程，但它们在实现这一目的的过程和结果上有着显著的区别。</p><h3 id="git-rebase" tabindex="-1">git rebase <a class="header-anchor" href="#git-rebase" aria-label="Permalink to &quot;git rebase&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git rebase</code> 命令的作用是将一个分支上的更改重新应用于另一个分支。它首先找到两个分支的共同祖先，然后将当前分支上从这个共同祖先以来的每个提交取消，并且暂时保存为补丁。这些补丁会按照原有顺序一一应用到目标分支的头部。</li><li><strong>作用</strong>：通过重排列提交历史，<code>git rebase</code> 创建了一个更线性的项目历史，这可以让项目历史更加清晰和简洁。</li><li><strong>应用场景</strong>：<code>git rebase</code> 常用于本地分支的整理，以及在将工作合并到主分支（如 <code>master</code> 或 <code>main</code>）之前更新本地分支。</li></ul><h3 id="git-merge" tabindex="-1">git merge <a class="header-anchor" href="#git-merge" aria-label="Permalink to &quot;git merge&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git merge</code> 命令用于将两个或两个以上的开发历史合并成一个统一的历史。在最简单的情况下，<code>git merge</code> 会把两个分支的末端（HEAD）指向的快照以及这两个分支的共同祖先进行合并。</li><li><strong>作用</strong>：<code>git merge</code> 通过创建一个新的 &quot;合并提交&quot; 来保持项目历史的分支结构，这个提交有两个父提交，分别指向合并前的两个分支的末端。</li><li><strong>应用场景</strong>：<code>git merge</code> 适用于将完成的功能合并回主分支，它保留了分支的历史和合并点，对于跟踪项目的历史很有帮助。</li></ul><h3 id="区别-2" tabindex="-1">区别 <a class="header-anchor" href="#区别-2" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li><strong>历史线性化</strong>：<code>git rebase</code> 会创建一个线性的提交历史，好像所有更改都是按顺序依次进行的，而 <code>git merge</code> 保留了真实的、分叉的历史。</li><li><strong>合并提交</strong>：<code>git merge</code> 会在合并时创建一个新的合并提交，这个提交有两个父节点，而 <code>git rebase</code> 不会创建新的合并提交。</li><li><strong>冲突解决</strong>：<code>git rebase</code> 和 <code>git merge</code> 都可能遇到冲突，但是 <code>git rebase</code> 需要在重放每个提交时解决冲突，可能会更加繁琐；<code>git merge</code> 只在最后进行一次合并时解决冲突。</li><li><strong>历史改写</strong>：<code>git rebase</code> 实际上是改写了历史（由于它移动了分支的基点），这意味着如果你的分支是与别人共享的，那么 <code>rebase</code> 操作可能会引起混乱。因此，一般推荐只对本地分支进行 <code>rebase</code>。</li></ul><p>总结来说，<code>git rebase</code> 和 <code>git merge</code> 都是合并分支的有效工具，选择使用哪一个取决于你想要的项目历史结构：如果你倾向于一个干净、线性的历史，可以选择 <code>rebase</code>；如果你想保留分支间的历史关系，可以选择 <code>merge</code>。</p><h2 id="说说-git-发生冲突的场景-如何解决" tabindex="-1">说说 git 发生冲突的场景？如何解决？ <a class="header-anchor" href="#说说-git-发生冲突的场景-如何解决" aria-label="Permalink to &quot;说说 git 发生冲突的场景？如何解决？&quot;">​</a></h2><p>在使用 Git 进行版本控制时，冲突（Conflict）是一个常见现象，尤其是在多人协作的项目中。冲突通常发生在以下几种场景：</p><h3 id="分支合并时" tabindex="-1">分支合并时 <a class="header-anchor" href="#分支合并时" aria-label="Permalink to &quot;分支合并时&quot;">​</a></h3><p>当你尝试合并两个分支时，如果这两个分支都对同一个文件的同一部分做了不同的修改，Git 将无法自动合并这些更改，此时就会发生冲突。</p><h3 id="拉取远程更改时" tabindex="-1">拉取远程更改时 <a class="header-anchor" href="#拉取远程更改时" aria-label="Permalink to &quot;拉取远程更改时&quot;">​</a></h3><p>当你执行 <code>git pull</code> 或 <code>git fetch</code> 后紧接着 <code>git merge</code> 操作，而你的本地仓库有尚未提交的更改，这些更改与远程仓库的更改在相同的文件的相同部分冲突时，也会导致冲突。</p><h3 id="rebase-操作时" tabindex="-1">rebase 操作时 <a class="header-anchor" href="#rebase-操作时" aria-label="Permalink to &quot;rebase 操作时&quot;">​</a></h3><p>在执行 <code>git rebase</code> 操作时，如果当前分支上的提交和被 rebase 的基分支在同一文件的同一位置有不同的更改，也会触发冲突。</p><h3 id="如何解决冲突" tabindex="-1">如何解决冲突 <a class="header-anchor" href="#如何解决冲突" aria-label="Permalink to &quot;如何解决冲突&quot;">​</a></h3><p>解决 Git 冲突通常涉及以下步骤：</p><h4 id="_1-识别冲突文件" tabindex="-1">1. 识别冲突文件 <a class="header-anchor" href="#_1-识别冲突文件" aria-label="Permalink to &quot;1. 识别冲突文件&quot;">​</a></h4><p>首先，通过执行 <code>git status</code> 命令来识别哪些文件存在冲突。</p><h4 id="_2-编辑冲突文件" tabindex="-1">2. 编辑冲突文件 <a class="header-anchor" href="#_2-编辑冲突文件" aria-label="Permalink to &quot;2. 编辑冲突文件&quot;">​</a></h4><p>手动编辑文件以解决冲突。Git 会在冲突的文件中插入特殊的标记，用于指示冲突的区域：</p><ul><li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 开始标记，表示你当前分支的版本。</li><li><code>=======</code> 分隔符，用于分割两个冲突的版本。</li><li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [other-branch-name]</code> 结束标记，表示另一个分支的版本。</li></ul><p>你需要决定保留哪个版本的更改，或者合并这两个版本的更改。编辑完成后，删除 Git 插入的标记。</p><h4 id="_3-添加和提交更改" tabindex="-1">3. 添加和提交更改 <a class="header-anchor" href="#_3-添加和提交更改" aria-label="Permalink to &quot;3. 添加和提交更改&quot;">​</a></h4><p>解决所有冲突后，使用 <code>git add [file]</code> 命令将解决了冲突的文件标记为已解决状态。然后，执行 <code>git commit</code> 命令来提交解决冲突后的更改。Git 会自动生成一个提交消息，通常不需要修改，直接保存即可。</p><h4 id="_4-继续之前的操作" tabindex="-1">4. 继续之前的操作 <a class="header-anchor" href="#_4-继续之前的操作" aria-label="Permalink to &quot;4. 继续之前的操作&quot;">​</a></h4><ul><li>如果冲突发生在合并操作中，解决冲突并提交后，合并操作就完成了。</li><li>如果冲突是在执行 <code>git rebase</code> 时发生的，解决所有冲突并提交后，需要使用 <code>git rebase --continue</code> 命令继续 rebase 操作。</li></ul><h4 id="_5-测试确保正确" tabindex="-1">5. 测试确保正确 <a class="header-anchor" href="#_5-测试确保正确" aria-label="Permalink to &quot;5. 测试确保正确&quot;">​</a></h4><p>在完成冲突解决并提交后，务必测试应用以确保更改没有引入任何错误。</p><p>解决 Git 冲突是版本控制过程中不可避免的一部分，尤其是在团队协作中。正确地解决冲突对于保持项目的健康发展至关重要。</p><h2 id="说说-git-reset-和-git-revert-的理解-区别" tabindex="-1">说说 git reset 和 git revert 的理解？区别？ <a class="header-anchor" href="#说说-git-reset-和-git-revert-的理解-区别" aria-label="Permalink to &quot;说说 git reset 和 git revert 的理解？区别？&quot;">​</a></h2><h2 id="git-reset-和-git-revert-的理解及区别" tabindex="-1">git reset 和 git revert 的理解及区别 <a class="header-anchor" href="#git-reset-和-git-revert-的理解及区别" aria-label="Permalink to &quot;git reset 和 git revert 的理解及区别&quot;">​</a></h2><p>在 Git 中，<code>git reset</code> 和 <code>git revert</code> 都是用来撤销之前的提交操作的命令，但它们在操作方式和影响上有着本质的区别。</p><h3 id="git-reset" tabindex="-1">git reset <a class="header-anchor" href="#git-reset" aria-label="Permalink to &quot;git reset&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git reset</code> 命令用于将当前分支的头部移动到指定的状态，不同的选项可以影响工作目录和索引（暂存区）。</li><li><strong>用法</strong>： <ul><li><code>git reset --soft [commit]</code>：仅仅移动 HEAD 指针，不改变索引和工作目录。</li><li><code>git reset --mixed [commit]</code>（默认）：移动 HEAD 指针，并且重置索引，但不改变工作目录。</li><li><code>git reset --hard [commit]</code>：移动 HEAD 指针，重置索引，并且重置工作目录。任何更改都会丢失。</li></ul></li><li><strong>应用场景</strong>：当你想要撤销一些未推送（或者即使已推送，但仅限于私有分支上的操作）的提交，并且可能要重写项目历史时使用。</li></ul><h3 id="git-revert" tabindex="-1">git revert <a class="header-anchor" href="#git-revert" aria-label="Permalink to &quot;git revert&quot;">​</a></h3><ul><li><strong>定义</strong>：<code>git revert</code> 命令用于生成一个新的提交，这个提交是用来撤销指定提交所做的更改。原始的提交历史保持不变。</li><li><strong>用法</strong>： <ul><li><code>git revert [commit]</code>：创建一个新的&quot;反向&quot;提交，用来撤销指定的提交。</li></ul></li><li><strong>应用场景</strong>：当你需要撤销某个提交的更改，并且这个提交已经推送到了共享仓库时使用。<code>git revert</code> 是一种在不改变项目历史的情况下撤销更改的安全方法。</li></ul><h3 id="区别-3" tabindex="-1">区别 <a class="header-anchor" href="#区别-3" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li><strong>影响历史</strong>：<code>git reset</code> 实质上是在重写项目历史。它通过移动分支的头部来实现，可能会导致丢失提交历史。而 <code>git revert</code> 通过创建一个新的提交来撤销更改，保留了原有的提交历史。</li><li><strong>安全性</strong>：在多人协作的项目中，<code>git revert</code> 被认为是更安全的撤销更改的方法。因为它不会改变已经存在的历史，而 <code>git reset</code> 可能会导致其他协作者的历史和当前仓库历史不一致。</li><li><strong>用途</strong>：<code>git reset</code> 通常用于本地更改和私有分支上的操作，以便在推送之前调整提交。<code>git revert</code> 用于已经推送到远程仓库的提交，确保团队成员之间的工作不会受到影响。</li></ul><p>总结来说，<code>git reset</code> 和 <code>git revert</code> 都是撤销更改的有用工具，但它们的使用场景和对项目历史的影响有着显著的区别。在团队协作的环境中，理解并正确使用这两个命令对于保持项目的稳定和团队成员之间的协作是非常重要的。</p>',135),l=[r];function c(d,h,n,s,g,u){return o(),a("div",null,l)}const q=e(t,[["render",c]]);export{m as __pageData,q as default};
