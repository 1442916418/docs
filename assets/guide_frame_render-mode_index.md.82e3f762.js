import{_ as e,o as r,c as a,Q as t}from"./chunks/framework.aea2adc8.js";const b=JSON.parse('{"title":"渲染模式","description":"","frontmatter":{},"headers":[],"relativePath":"guide/frame/render-mode/index.md","filePath":"guide/frame/render-mode/index.md","lastUpdated":1710382600000}'),i={name:"guide/frame/render-mode/index.md"},n=t('<h1 id="渲染模式" tabindex="-1">渲染模式 <a class="header-anchor" href="#渲染模式" aria-label="Permalink to &quot;渲染模式&quot;">​</a></h1><h2 id="csr-客户端渲染-client-side-rendering" tabindex="-1">CSR（客户端渲染 Client Side Rendering） <a class="header-anchor" href="#csr-客户端渲染-client-side-rendering" aria-label="Permalink to &quot;CSR（客户端渲染 Client Side Rendering）&quot;">​</a></h2><p>在客户端渲染中，服务器仅发送一个最初几乎为空的HTML页面到客户端，真正的内容渲染工作是在浏览器中，通过JavaScript来完成的。客户端渲染的网页通常会在用户的浏览器中请求数据，然后使用这些数据来动态生成页面内容。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>用户体验</strong>：一旦应用加载完成，页面间的切换可以非常快，无需重新加载页面。</li><li><strong>前后端分离</strong>：更容易分离前后端开发，提高开发效率。</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>SEO</strong>：由于内容是动态生成的，搜索引擎抓取可能会有问题，对SEO不利。</li><li><strong>首次加载时间</strong>：需要加载整个应用的脚本和框架，可能会导致较慢的首次页面加载体验。</li></ul><h2 id="ssr-服务器端渲染-server-side-rendering" tabindex="-1">SSR（服务器端渲染 Server Side Rendering） <a class="header-anchor" href="#ssr-服务器端渲染-server-side-rendering" aria-label="Permalink to &quot;SSR（服务器端渲染 Server Side Rendering）&quot;">​</a></h2><p>服务器端渲染指的是在服务器上运行相应的Web应用或页面逻辑，生成并发送一个完整的HTML页面给客户端，从而客户端可以直接渲染显示。</p><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>SEO</strong>：由于服务器直接返回已渲染的页面，搜索引擎能够更好地索引这些内容。</li><li><strong>首屏加载速度</strong>：用户可以更快地看到完整页面，提高首次加载的体验。</li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>服务器负载</strong>：每个页面请求都需要服务器处理渲染，对服务器资源消耗较大。</li><li><strong>用户体验</strong>：页面间的跳转可能需要完整的页面重新加载，用户体验可能不如CSR。</li></ul><h2 id="ssg-静态站点生成-static-site-generation" tabindex="-1">SSG（静态站点生成 Static Site Generation） <a class="header-anchor" href="#ssg-静态站点生成-static-site-generation" aria-label="Permalink to &quot;SSG（静态站点生成 Static Site Generation）&quot;">​</a></h2><p>静态站点生成是在构建时预渲染出所有页面的HTML，这些静态文件可以直接部署到CDN上。这种方式适合内容不经常变动的网站。</p><h3 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>性能和安全性</strong>：静态文件可以被缓存，加载速度快，且由于没有数据库查询等操作，更加安全。</li><li><strong>SEO</strong>：由于内容在构建时就已生成，对搜索引擎友好。</li></ul><h3 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>内容更新</strong>：每次内容更新都需要重新构建整个站点，对于频繁更新内容的网站来说可能不太适合。</li><li><strong>动态功能限制</strong>：静态站点难以实现实时的动态功能，如用户评论等。</li></ul><h2 id="isr-增量式的网站渲染-incremental-site-rendering" tabindex="-1">ISR（增量式的网站渲染 Incremental Site Rendering） <a class="header-anchor" href="#isr-增量式的网站渲染-incremental-site-rendering" aria-label="Permalink to &quot;ISR（增量式的网站渲染 Incremental Site Rendering）&quot;">​</a></h2><p>增量静态重新生成（Incremental Static Regeneration, ISR）是一种现代的网页生成策略，结合了静态站点生成（SSG）的优点和服务器端渲染（SSR）的灵活性。ISR允许开发者为每个页面设置重新生成的时间间隔，仅当页面被访问时，并且自上次生成以来已经超过了设定的时间，页面才会被重新生成并缓存。这种方法适用于部分内容需要定期更新的场景，而不需要每次内容变化都重新构建整个站点。</p><h3 id="优点-3" tabindex="-1">优点 <a class="header-anchor" href="#优点-3" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>性能优化</strong>：通过静态文件服务页面，可以利用CDN优化全球访问速度，提高网站的加载性能。</li><li><strong>更佳的SEO</strong>：由于页面是预先生成的，因此它们对搜索引擎更友好，有助于提高网站的SEO排名。</li><li><strong>成本效率</strong>：相较于传统的SSR，ISR减少了服务器渲染页面的次数，可以有效减轻服务器负载，降低资源消耗。</li><li><strong>内容更新灵活</strong>：通过设置不同页面的重新生成时间，ISR能够在不牺牲性能的情况下，实现内容的即时更新。</li></ul><h3 id="缺点-3" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>复杂性增加</strong>：实现ISR需要特定的框架支持（如Next.js），且配置和管理相对复杂，对开发者的技术要求更高。</li><li><strong>更新延迟</strong>：虽然ISR可以减少内容更新的延迟，但如果设置的重新生成间隔较长，仍然可能导致用户看到过时的内容。</li><li><strong>资源消耗</strong>：在高流量网站上，频繁的页面重新生成可能会消耗大量的服务器资源，尤其是在内容频繁更新的情况下。</li></ul><h2 id="dpr-分布式持久渲染-distributed-persistent-rendering" tabindex="-1">DPR（分布式持久渲染 Distributed Persistent Rendering） <a class="header-anchor" href="#dpr-分布式持久渲染-distributed-persistent-rendering" aria-label="Permalink to &quot;DPR（分布式持久渲染 Distributed Persistent Rendering）&quot;">​</a></h2><p>是一种较新的web开发概念，旨在解决静态站点生成（SSG）和增量静态重新生成（ISR）在处理大量页面时的限制。DPR允许开发者仅在用户请求时首次生成并持久化（即保存）页面，而非在构建时生成所有页面。这种方法特别适合那些页面数量庞大，但许多页面访问频率较低的应用。</p><h3 id="优点-4" tabindex="-1">优点 <a class="header-anchor" href="#优点-4" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>扩展性</strong>：对于拥有大量页面的网站，DPR允许按需渲染页面，从而避免了构建过程中的性能瓶颈。</li><li><strong>效率提升</strong>：只有被请求的页面才会被渲染和缓存，减少了无谓的资源消耗，提高了网站整体的生成和部署效率。</li><li><strong>用户体验</strong>：虽然第一次请求某个页面时需要等待渲染，但一旦页面被缓存，后续访问将非常快速，同时还能保证内容的实时性。</li><li><strong>成本优化</strong>：减少了预先渲染所有页面所需的服务器资源和时间，尤其适合内容丰富但某些页面访问量较低的网站。</li></ul><h3 id="缺点-4" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-4" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>首次加载延迟</strong>：对于首次被请求的页面，用户可能会遇到较长的加载时间，因为页面需要在服务器端实时渲染。</li><li><strong>SEO影响</strong>：对搜索引擎爬虫而言，首次爬取时如果页面还未被渲染和缓存，可能会影响网站内容的及时收录。</li><li><strong>实现复杂性</strong>：DPR需要特定的基础设施支持，如边缘计算和云函数，这可能增加开发和维护的复杂度及成本。</li><li><strong>缓存管理</strong>：需要有效管理缓存策略，以确保内容更新能够及时反映到用户端，同时避免缓存过期导致的额外渲染成本。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>DPR提供了一种灵活的页面渲染策略，特别适合那些页面众多且更新频率不一的大型网站。它通过按需渲染来优化资源使用和提高扩展性，但也带来了首次访问延迟和实现复杂性的挑战。选择使用DPR时，需要权衡其优势和潜在的劣势，确保它符合项目的具体需求和目标。</p>',33),l=[n];function o(s,d,h,g,c,u){return r(),a("div",null,l)}const m=e(i,[["render",o]]);export{b as __pageData,m as default};
