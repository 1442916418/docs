import{_ as o,o as l,c as e,Q as r}from"./chunks/framework.aea2adc8.js";const b=JSON.parse('{"title":"浏览器","description":"","frontmatter":{},"headers":[],"relativePath":"guide/computer/browser/review.md","filePath":"guide/computer/browser/review.md","lastUpdated":1698221979000}'),i={name:"guide/computer/browser/review.md"},t=r(`<h1 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h1><h2 id="从输入url到页面加载的全过程" tabindex="-1">从输入URL到页面加载的全过程 <a class="header-anchor" href="#从输入url到页面加载的全过程" aria-label="Permalink to &quot;从输入URL到页面加载的全过程&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-1.image" alt="从输入URL到页面加载的主干流程"></p><ol><li><p><strong>输入URL</strong>：首先在浏览器中输入URL。</p></li><li><p><strong>查找缓存</strong>：</p><ul><li>浏览器会先查看<strong>浏览器缓存</strong>、<strong>系统缓存</strong>、<strong>路由缓存</strong>中是否有该地址的页面。如果有，则显示页面内容。如果没有，则进入下一步。</li><li><strong>浏览器缓存</strong>：浏览器会记录DNS一段时间，因此，这是解析DNS请求的第一个地方。</li><li><strong>操作系统缓存</strong>：如果在浏览器缓存中没有找到相应的记录，则会查询操作系统缓存。</li><li><strong>路由器缓存</strong>：如果上述两个步骤都未能成功获取DNS记录，会继续搜索路由器缓存。</li><li><strong>ISP缓存</strong>：如果前三个步骤都失败，会继续向ISP搜索。</li></ul></li><li><p><strong>DNS域名解析</strong>：</p><ul><li>浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。需要注意的是，DNS服务器是基于UDP的，因此会使用UDP协议。</li></ul></li><li><p><strong>建立TCP连接</strong>：</p><ul><li>解析出IP地址后，根据IP地址和默认的80端口，浏览器与服务器建立TCP连接。</li></ul></li><li><p><strong>发起HTTP请求</strong>：</p><ul><li>浏览器发起HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器。</li></ul></li><li><p><strong>服务器响应并返回结果</strong>：</p><ul><li>服务器对浏览器请求做出响应，并将对应的HTML文件发送给浏览器。</li></ul></li><li><p><strong>关闭TCP连接</strong>：</p><ul><li>通过四次挥手来释放TCP连接。</li></ul></li><li><p><strong>浏览器渲染</strong>：</p><ul><li>客户端（浏览器）接收到数据后，开始解析HTML内容并渲染。具体流程包括： <ol><li><strong>构建DOM树</strong>：词法分析后解析成DOM树，该树是由DOM元素及属性节点组成，树的根是document对象。</li><li><strong>构建CSS规则树</strong>：生成CSS规则树。</li><li><strong>构建Render树</strong>：浏览器将DOM和CSSOM结合，生成渲染树。</li><li><strong>布局</strong>：计算每个节点在屏幕中的位置。</li><li><strong>绘制</strong>：遍历Render树，并使用UI后端层绘制每个节点。</li></ol></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-1.image" alt="浏览器渲染流程图"></p></li><li><p><strong>JS引擎解析过程</strong>：</p><ul><li>JS引擎开始执行JS代码，该过程包括解释阶段、预处理阶段、执行阶段、生成执行上下文、变量对象、作用域链和回收机制等。 <ol><li><strong>创建window对象</strong>：当页面加载时，window对象被创建，所有的全局变量和函数都成为window的属性和方法。DOM Tree也会映射在window的document对象上。当关闭网页或浏览器时，全局执行环境会被销毁。</li><li><strong>加载文件</strong>：JS引擎首先检查JS代码的语法和词法是否合法。如果合法，进入预编译阶段。</li><li><strong>预编译</strong>：在此阶段，浏览器会寻找全局变量声明，并将它们作为window的属性加入到window对象中，同时赋值为&#39;undefined&#39;；也会寻找全局函数声明，并将它们作为window的方法加入，将函数体赋值给它们。</li><li><strong>解释执行</strong>：当执行到变量时，会进行赋值操作。如果变量没有预先声明，则直接赋值。对于简单的数据类型，如字符串或整数，直接将值存储在变量的存储空间中。而对于对象，会将指针指向变量的存储空间。</li></ol></li></ul></li></ol><p><strong>相关链接</strong>：</p><ul><li><a href="https://juejin.cn/post/7005468491067162655" target="_blank" rel="noreferrer">DNS域名解析过程</a></li><li><a href="https://juejin.cn/post/6992597760935460901" target="_blank" rel="noreferrer">浏览器的工作原理</a></li></ul><h2 id="在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议" tabindex="-1">在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？ <a class="header-anchor" href="#在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议" aria-label="Permalink to &quot;在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？&quot;">​</a></h2><p>当在浏览器中输入一个URL并按下回车后，将会经历以下过程并涉及到相应的协议：</p><ol><li><p><strong>域名解析 (DNS协议)</strong> 浏览器首先需要将URL中的域名解析为对应的IP地址。这一过程涉及到DNS协议。首先，浏览器会检查是否有该域名的IP地址缓存，如果没有则会向本地DNS服务器发送查询请求。DNS查询可以分为两种：递归查询和迭代查询。在迭代查询中，本地DNS服务器向根域名服务器发送查询请求，根域名服务器告知该域名的顶级域名服务器地址，然后本地服务器再给该顶级域名服务器发送查询请求，如此反复直到获得该域名的IP地址。值得注意的是，DNS查询通常基于UDP协议。</p></li><li><p><strong>建立连接 (HTTP/HTTPS、TCP协议)</strong> 浏览器获得IP地址后，会尝试与服务器建立一个连接。若使用的是HTTP，那么浏览器会建立一个明文连接。若是HTTPS，则首先进行TLS握手以加密连接。HTTP或HTTPS请求报文会传递给TCP层处理，因此还涉及到TCP协议。</p></li><li><p><strong>数据传输 (IP、ARP、以太网协议等)</strong> TCP层可能会将HTTP数据包分片，分片的依据是路径MTU和MSS。接着，TCP数据包传送至IP层，涉及到IP协议。IP层负责通过路由选择合适的路径，跳转至目标地址。在同一网段内，地址寻址是通过以太网协议实现。若要知道目的IP地址对应的物理地址，则需使用ARP协议。</p></li></ol><p>其中：</p><ul><li><p><code>DNS协议、HTTP协议、HTTPS协议属于应用层</code> 应用层是网络体系结构中的最高层，负责决定进程间通信的性质以满足用户需求。它旨在为用户的应用进程提供服务，并为应用进程之间的信息交换和远程操作提供支持。</p></li><li><p><code>TCP/UDP属于传输层</code> 传输层任务是负责主机之间进程的通信。其中，TCP提供面向连接的可靠服务，而UDP则提供无连接的服务，并不保证数据可靠交付。</p></li><li><p><code>IP协议、ARP协议属于网络层</code> 网络层负责选择合适的路由以确保数据从源主机传输到目标主机。</p></li><li><p><strong>数据链路层</strong> 数据链路层的任务是将网络层的IP数据报组装成帧，然后在相邻的节点间的链路上传送这些帧。</p></li><li><p><strong>物理层</strong> 物理层负责透明地传送比特流。传输信息所用的物理媒体（如双绞线、同轴电缆、光缆）位于物理层以下。</p></li></ul><h2 id="浏览器的主要功能" tabindex="-1">浏览器的主要功能 <a class="header-anchor" href="#浏览器的主要功能" aria-label="Permalink to &quot;浏览器的主要功能&quot;">​</a></h2><p>浏览器的核心功能是向服务器发送请求并在浏览器窗口中呈现选择的网络资源。这些资源通常是指HTML文档，但也可以是PDF、图片或其他类型的文件。用户使用URI（统一资源标识符）来指定这些资源的位置。</p><h2 id="浏览器的工作原理" tabindex="-1">浏览器的工作原理 <a class="header-anchor" href="#浏览器的工作原理" aria-label="Permalink to &quot;浏览器的工作原理&quot;">​</a></h2><p>渲染引擎开始时从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>接下来的基本流程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef6cb226b374e89914a2315e4ca9ba9~tplv-k3u1fbpfcp-zoom-1.image" alt="流程"></p><p><strong>图</strong>：渲染引擎的基本流程。</p><ol><li><strong>解析HTML文档</strong>：渲染引擎将开始解析 HTML 文档，并逐个将标记转化成“内容树”上的 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM" target="_blank" rel="noreferrer">DOM</a> 节点。</li><li><strong>解析CSS样式</strong>：同时，渲染引擎也会解析外部 CSS 文件和样式元素中的样式数据。这些带有视觉指令的样式信息用于创建“渲染树”。</li><li><strong>渲染树</strong>：渲染树包含有视觉属性的矩形（如颜色和尺寸）。这些矩形的排列顺序决定了它们在屏幕上的显示顺序。</li><li><strong>布局</strong>：在渲染树构建完成后，进入“布局”阶段，为每个节点分配在屏幕上的确切坐标。</li><li><strong>绘制</strong>：渲染引擎遍历渲染树，并使用用户界面后端层将每个节点绘制出来。</li></ol><p>为了提供更佳的用户体验，渲染引擎会尽量快速地显示内容在屏幕上。它不必等待整个 HTML 文档完全解析完毕，而是会开始构建渲染树并进行布局。同时，它会继续接收并处理来自网络的其他内容。</p><h2 id="浏览器的主要组成部分" tabindex="-1">浏览器的主要组成部分 <a class="header-anchor" href="#浏览器的主要组成部分" aria-label="Permalink to &quot;浏览器的主要组成部分&quot;">​</a></h2><h2 id="_1-用户界面" tabindex="-1">1. 用户界面 <a class="header-anchor" href="#_1-用户界面" aria-label="Permalink to &quot;1. 用户界面&quot;">​</a></h2><p>包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的请求页面外，其他所有显示的部分都属于用户界面。</p><h2 id="_2-浏览器引擎" tabindex="-1">2. 浏览器引擎 <a class="header-anchor" href="#_2-浏览器引擎" aria-label="Permalink to &quot;2. 浏览器引擎&quot;">​</a></h2><p>在用户界面和呈现引擎之间传送指令。</p><h2 id="_3-呈现引擎" tabindex="-1">3. 呈现引擎 <a class="header-anchor" href="#_3-呈现引擎" aria-label="Permalink to &quot;3. 呈现引擎&quot;">​</a></h2><p>负责显示请求的内容。当请求的内容是 HTML 时，它负责解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。</p><h2 id="_4-网络" tabindex="-1">4. 网络 <a class="header-anchor" href="#_4-网络" aria-label="Permalink to &quot;4. 网络&quot;">​</a></h2><p>用于网络调用，如 HTTP 请求。其接口独立于平台，并为所有平台提供底层实现。</p><h2 id="_5-用户界面后端" tabindex="-1">5. 用户界面后端 <a class="header-anchor" href="#_5-用户界面后端" aria-label="Permalink to &quot;5. 用户界面后端&quot;">​</a></h2><p>用于绘制基础的窗口小部件，如组合框和窗口。其提供了一个与平台无关的通用接口，底层使用操作系统的用户界面方法。</p><h2 id="_6-javascript-解释器" tabindex="-1">6. JavaScript 解释器 <a class="header-anchor" href="#_6-javascript-解释器" aria-label="Permalink to &quot;6. JavaScript 解释器&quot;">​</a></h2><p>用于解析和执行 JavaScript 代码。</p><h2 id="_7-数据存储" tabindex="-1">7. 数据存储 <a class="header-anchor" href="#_7-数据存储" aria-label="Permalink to &quot;7. 数据存储&quot;">​</a></h2><p>这是浏览器的持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。HTML5 规范定义了“网络数据库”，这是一个完整但轻便的浏览器内部数据库。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83cb61cb9de4a65abeb95e50608af48~tplv-k3u1fbpfcp-watermark.awebp" alt="流程"></p><p><strong>图</strong>：浏览器的主要组件。</p><p>与大多数浏览器不同，Chrome 浏览器的每个标签页都有自己的呈现引擎实例，即每个标签页都运行在一个独立的进程中。</p><h2 id="浏览器是如何渲染ui的" tabindex="-1">浏览器是如何渲染UI的？ <a class="header-anchor" href="#浏览器是如何渲染ui的" aria-label="Permalink to &quot;浏览器是如何渲染UI的？&quot;">​</a></h2><p>当浏览器要渲染一个页面时，它会经历以下步骤：</p><ol><li><strong>解析HTML</strong>：首先，浏览器从服务器获取HTML文件，并开始解析它。这一解析过程将形成一个结构化的节点树，称为DOM Tree（Document Object Model Tree）。</li><li><strong>解析CSS</strong>：与HTML解析同时进行，浏览器也会解析页面上的CSS，并形成Style Rules。</li><li><strong>生成Render Tree</strong>：有了DOM Tree和Style Rules后，浏览器会结合它们生成一个Render Tree。这一树结构表明了页面上所有可见的DOM内容以及它们的样式信息。</li><li><strong>布局</strong>：在Render Tree生成后，浏览器开始布局阶段。此时，它会为每个可见的元素计算在屏幕上的确切位置和大小。</li><li><strong>绘制</strong>：布局结束后，浏览器将开始绘制阶段。此时，它会遍历Render Tree的每个节点，并利用GPU将其绘制到屏幕上。</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67b1336692f540c9a81756f93e82c2f5~tplv-k3u1fbpfcp-watermark.image" alt="渲染过程图"></p><h2 id="dom-tree是如何构建的" tabindex="-1">DOM Tree是如何构建的？ <a class="header-anchor" href="#dom-tree是如何构建的" aria-label="Permalink to &quot;DOM Tree是如何构建的？&quot;">​</a></h2><p>DOM Tree的构建是浏览器解析HTML文件的结果，以下是构建DOM Tree的步骤：</p><ol><li><strong>转码</strong>：首先，浏览器将从服务器接收到的二进制数据转换成字符串。这一转换过程需要根据HTML文档指定的编码格式（如UTF-8）进行。</li><li><strong>生成Tokens</strong>：在得到HTML字符串后，浏览器会将其解析为多个Tokens。这些Tokens是HTML文档的基础构建块，如元素、属性和内容。</li><li><strong>构建Nodes</strong>：解析器会使用Tokens来构建DOM节点。这些节点会有特定的属性，并通过指针与其父节点、子节点和兄弟节点连接起来。此外，每个节点还与一个特定的treeScope相关联。</li><li><strong>生成DOM Tree</strong>：最后，通过上述构建的节点及它们之间的关系，浏览器将生成DOM Tree。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0f577836c4705bb582b2ac15bc5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="DOM构建过程图"></p><p>以下是完善和修复后的文档内容，使用了Markdown格式：</p><h2 id="浏览器重绘与重排的区别" tabindex="-1">浏览器重绘与重排的区别？ <a class="header-anchor" href="#浏览器重绘与重排的区别" aria-label="Permalink to &quot;浏览器重绘与重排的区别？&quot;">​</a></h2><ul><li><p><strong>重排/回流（Reflow）</strong>：当 DOM 的变化影响了元素的几何信息时，浏览器需要重新计算元素的几何属性，并将其安放在界面中的正确位置。这个过程称为重排。这表现为重新生成布局，重新排列元素。</p></li><li><p><strong>重绘(Repaint)</strong>：当元素的外观发生改变，但没有改变布局时，重新把元素的外观绘制出来的过程称为重绘。这表现为某些元素的外观被改变。</p></li></ul><p>单纯地改变元素的外观并不会引发重排，但当浏览器完成重排之后，将重新绘制受到此次重排影响的部分。重排和重绘的性能代价是高昂的，会破坏用户体验，并使UI展示缓慢。相对而言，重排的性能影响更大。在必要的情况下，通常更倾向于选择代价较小的重绘。</p><p>『重绘』不一定会引发『重排』，但『重排』必然会引发『重绘』。</p><h2 id="如何触发重排和重绘" tabindex="-1">如何触发重排和重绘？ <a class="header-anchor" href="#如何触发重排和重绘" aria-label="Permalink to &quot;如何触发重排和重绘？&quot;">​</a></h2><p>造成重排或重绘的因素有：</p><ul><li>添加、删除、更新DOM节点</li><li>使用 <code>display: none</code> 隐藏一个DOM节点会触发重排和重绘</li><li>使用 <code>visibility: hidden</code> 隐藏一个DOM节点只触发重绘，因为没有几何变化</li><li>移动或为页面中的DOM节点添加动画</li><li>添加一个样式表或调整样式属性</li><li>用户行为，如调整窗口大小，改变字号，或滚动</li></ul><h2 id="如何避免重绘或重排" tabindex="-1">如何避免重绘或重排？ <a class="header-anchor" href="#如何避免重绘或重排" aria-label="Permalink to &quot;如何避免重绘或重排？&quot;">​</a></h2><ol><li><p><strong>集中改变样式</strong>：尽量一次性修改 DOM 的样式，避免逐条修改样式。</p></li><li><p><strong>避免在循环中操作DOM</strong>：不要在循环中频繁地操作DOM或计算样式。</p></li><li><p><strong>使用固定位置</strong>：对于动画的 HTML 元素使用 <code>position: fixed</code> 或 <code>position: absolute</code>。</p></li><li><p><strong>避免使用表格布局</strong>：小的布局变化可能导致整个表格的重新布局。</p></li><li><p><strong>修改离屏元素</strong>：尽量修改 <code>position: absolute</code> 或 <code>position: fixed</code> 的元素，这样对其他元素影响较小。</p></li><li><p><strong>使用硬件加速</strong>：利用 GPU 加速，使用 CSS 的 <code>translate3d</code> 或其他3D变换。</p></li><li><p><strong>提升为合成层</strong>：将元素提升为合成层，这样当元素变化时只会触发复合而不是布局或绘制。</p><p>提升合成层的优点：</p><ul><li>合成层的位图由 GPU 合成，比 CPU 处理更快。</li><li>当需要重绘时，只会重绘该层，不会影响其他层。</li><li>对于 <code>transform</code> 和 <code>opacity</code> 变化，不会触发重排或重绘。</li></ul><p>最好的提升方法是使用 CSS 的 <code>will-change</code> 属性：</p><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">#target</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">will-change</span><span style="color:#E1E4E8;">: transform;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">#target</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">will-change</span><span style="color:#24292E;">: transform;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>更多关于合成层的详解请查看 <a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noreferrer">无线性能优化：Composite</a>.</p></li></ol><h2 id="介绍下304过程" tabindex="-1">介绍下304过程 <a class="header-anchor" href="#介绍下304过程" aria-label="Permalink to &quot;介绍下304过程&quot;">​</a></h2><p>浏览器缓存技术旨在减少不必要的网络请求，从而提高页面加载速度。304状态码和相关的HTTP头部都是为此而生。当浏览器第二次请求某个资源时，它可能不需要重新获取整个资源。相反，如果资源未更改，它只需知道这一点，并使用缓存版本。以下是这个过程的详细步骤：</p><ol><li><p><strong>强缓存检查</strong>：</p><ul><li>当浏览器请求一个资源时，首先检查该资源的<code>Expires</code>和<code>Cache-Control</code>。<code>Expires</code>基于特定的绝对过期时间，但如果本地时间被修改，可能会导致缓存失效。为了避免这种情况，可以使用<code>Cache-Control: max-age</code>来指定资源的最大生命周期。</li><li>如果强缓存有效，浏览器将直接使用缓存资源，不会发起任何网络请求。在这种情况下，虽然状态仍为200，但浏览器开发者工具会显示“from cache”字样。</li></ul></li><li><p><strong>协商缓存检查</strong>：</p><ul><li>当强缓存失效后，浏览器将进入协商缓存阶段。</li><li>首先检查<code>ETag</code>。<code>ETag</code>确保资源的每个版本都是唯一的，因此任何对资源的更改都会导致<code>ETag</code>值更改。在第二次请求中，浏览器会将之前获取到的<code>ETag</code>值放在<code>If-None-Match</code>头中发给服务器。如果服务器发现<code>ETag</code>匹配，意味着资源未更改，它将返回304状态码。</li><li>如果<code>ETag</code>不存在或不匹配，浏览器和服务器将使用<code>Last-Modified</code>和<code>If-Modified-Since</code>机制。<code>Last-Modified</code>标明资源的最后修改时间。在随后的请求中，浏览器会使用<code>If-Modified-Since</code>头发送它上次知道的最后修改时间。如果该时间匹配服务器上资源的最后修改时间，服务器将返回304状态码。</li></ul></li></ol><h2 id="浏览器的缓存机制-强制缓存-协商缓存" tabindex="-1">浏览器的缓存机制：强制缓存 &amp; 协商缓存 <a class="header-anchor" href="#浏览器的缓存机制-强制缓存-协商缓存" aria-label="Permalink to &quot;浏览器的缓存机制：强制缓存 &amp; 协商缓存&quot;">​</a></h2><p>浏览器的缓存机制旨在提高网页的加载速度和用户体验，通过避免重新获取未更改的资源来节省带宽和时间。整个缓存机制基于请求-响应模型。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-1.image" alt="缓存示意图"></p><p>以下是详细的缓存机制：</p><ul><li><p><strong>强制缓存</strong>：</p><ul><li>强制缓存是指浏览器缓存查找该请求结果，并根据缓存规则决定是否使用缓存的过程。</li><li>强制缓存的标识是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>的优先级更高。</li><li>强制缓存的三种情况： <ol><li>如果缓存不存在，那么直接发起新的请求。</li><li>如果缓存存在但已失效，则进入协商缓存阶段。</li><li>如果缓存存在且仍有效，则直接使用缓存数据。</li></ol></li></ul></li><li><p><strong>协商缓存</strong>：</p><ul><li>如果强制缓存失效，浏览器会带着缓存的头信息向服务器发送请求，检查资源是否更改。</li><li>协商缓存的标识有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级更高。</li><li>协商缓存的两种情况： <ol><li>如果缓存仍然有效，则服务器返回304状态码，通知浏览器继续使用缓存。</li><li>如果缓存已失效，则服务器返回新的资源和200状态码。</li></ol></li></ul></li></ul><p>为了更深入地理解浏览器的缓存机制，你可以查看这篇详细的文章：<a href="https://juejin.cn/post/6992843117963509791" target="_blank" rel="noreferrer"># 彻底理解浏览器的缓存机制</a>。</p><h2 id="进程、线程与协程的区别" tabindex="-1">进程、线程与协程的区别 <a class="header-anchor" href="#进程、线程与协程的区别" aria-label="Permalink to &quot;进程、线程与协程的区别&quot;">​</a></h2><p><strong>进程</strong>：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是系统进行资源分配和调度的基本单位，并且是应用程序运行的载体。进程是一种抽象的概念，虽然没有统一的定义，但它通常被视为是一个独立的运行环境。</p><p><strong>线程</strong>：线程是程序执行中的一个单独的顺序控制流程，是程序执行流的最小单元，也是处理器调度和分派的基本单位。一个进程可以由一个或多个线程组成，线程共享该进程的所有资源。线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。</p><p><strong>协程</strong>：协程，又称为微线程(Coroutine)，是一种用户态的轻量级线程，有点类似于线程，但协程完全由程序控制，比线程更加轻量。</p><p><strong>关系与区别</strong>：</p><ul><li>『重绘』不一定会出现『重排』，但『重排』肯定会引起『重绘』。</li><li>线程是进程的子集，一个进程可以拥有多个线程。</li><li>协程是线程的子集，可以在一个线程中实现多个协程，多个协程之间可以并发执行。</li></ul><h2 id="如何触发进程间的通信" tabindex="-1">如何触发进程间的通信？ <a class="header-anchor" href="#如何触发进程间的通信" aria-label="Permalink to &quot;如何触发进程间的通信？&quot;">​</a></h2><p><strong>进程间通信</strong>：由于每个进程都有自己独立的地址空间，一个进程无法直接访问另一个进程的局部变量和数据结构。因此，进程间需要一种机制来交换数据，这就是进程间通信(IPC, Inter-Process Communication)。</p><p>以下是常见的进程间通信方式：</p><ul><li><p><strong>管道 (Pipe)</strong>：它是一种半双工的通信方式，数据只能单向流动，并且只能在有亲缘关系的进程间使用，通常指父子进程关系。</p></li><li><p><strong>命名管道 (Named Pipe)</strong>：与管道相似，但它允许无亲缘关系的进程间进行通信。</p></li><li><p><strong>消息队列 (Message Queue)</strong>：消息队列是一种列表的形式，存放在内核中，可以由一个进程发送，并由另一个进程读取。</p></li><li><p><strong>信号 (Signal)</strong>：是一种异步的通信方式，可以用来通知接收进程某个事件已经发生。</p></li><li><p><strong>信号量 (Semaphore)</strong>：主要作为进程间及同一进程不同线程之间的同步手段。</p></li><li><p><strong>共享内存 (Shared Memory)</strong>：多个进程共享一段内存地址空间，其中的数据可以被任何一个共享该内存的进程访问。</p></li><li><p><strong>套接字 (Socket)</strong>：它是支持TCP/IP的网络通信的基本操作单元，可用于不同机器间的进程通信。</p></li></ul><p><strong>如何避免频繁的进程间通信</strong>：频繁的进程间通信会增加系统的负担，所以我们应该尽量减少IPC的频率。一种方法是将数据缓存起来，一次性发送，或者将多个小的消息组合成一个大的消息再发送。</p><h2 id="优化进程间的通信" tabindex="-1">优化进程间的通信 <a class="header-anchor" href="#优化进程间的通信" aria-label="Permalink to &quot;优化进程间的通信&quot;">​</a></h2><p>为了优化进程间的通信，我们可以采取以下策略：</p><ol><li><strong>缓冲区</strong>：使用缓冲区可以减少进程间通信的次数，从而提高效率。</li><li><strong>批处理</strong>：将多个小消息组合成一个大的消息进行发送，可以减少通信的次数。</li><li><strong>避免频繁的数据交换</strong>：只在必要时才进行数据交换。</li><li><strong>使用更高效的通信机制</strong>：例如，使用共享内存通信比使用消息队列要快。</li></ol><p>参考链接：</p><ul><li><a href="https://juejin.cn/post/7005465381791875109" target="_blank" rel="noreferrer">一文搞懂进程、线程、协程及JS协程的发展</a></li><li><a href="https://juejin.cn/post/6993095345576083486" target="_blank" rel="noreferrer">深入了解现代 Web 浏览器</a></li><li><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noreferrer">无线性能优化：Composite</a></li></ul><h2 id="js垃圾回收机制" tabindex="-1">JS垃圾回收机制 <a class="header-anchor" href="#js垃圾回收机制" aria-label="Permalink to &quot;JS垃圾回收机制&quot;">​</a></h2><p>JavaScript 的性能和其垃圾回收机制有着密切的关系。不正确的内存使用会导致页面响应缓慢，而一个良好的垃圾回收策略可以确保页面运行流畅。</p><ol><li><p><strong>内存泄漏的影响</strong><br> 在项目中，如果存在大量未释放的内存（例如堆内存、栈内存或执行上下文），页面的性能可能会受到影响。不被适当释放的代码操作可能导致内存泄漏。因此，要尽量减少不必要的闭包使用，因为闭包可能会占用额外的内存。</p></li><li><p><strong>浏览器的垃圾回收机制</strong><br> 浏览器的 JavaScript 引擎具有自动垃圾回收机制（<code>GC: Garbage Collection</code>）。垃圾收集器会定期找出不再使用的变量，并释放其内存。</p><ul><li><p><strong>标记清除</strong>：此策略是 JavaScript 中最常见的垃圾回收机制。当变量进入执行环境时，它们被标记为“进入环境”。当变量离开执行环境时，它们被标记为“离开环境”。垃圾回收器将定期销毁这些带标记的值，并回收其内存。</p></li><li><p><strong>引用计数</strong>：这是 IE 浏览器使用的策略。每当对某个对象的引用数量增加时，计数值就会加1；当引用减少时，计数值就减1。当计数值为0时，说明对象不再被引用，浏览器会回收其内存。</p></li><li><p><strong>查找引用</strong>：这是谷歌浏览器使用的策略。浏览器会不定时地检查当前的内存引用。如果某个对象没有被引用，则浏览器会回收它的内存。</p></li></ul></li><li><p><strong>优化手段</strong></p><ul><li><strong>手动释放内存</strong><ul><li><strong>堆内存</strong>：例如，可以通过将对象引用设置为 <code>null</code> 来释放对象。</li><li><strong>栈内存</strong>：确保不再使用的上下文中的变量没有外部引用。</li></ul></li></ul></li><li><p><strong>内存泄漏的常见原因</strong><br> 在 JS 中，常见的内存泄露主要有以下几种情况：</p><ul><li><strong>全局变量</strong>：不必要的全局变量会持续占用内存。</li><li><strong>闭包</strong>：不适当地使用闭包可能会导致内存泄漏。</li><li><strong>DOM 元素引用</strong>：JavaScript 对象与未使用的DOM元素之间的引用。</li><li><strong>定时器</strong>：未清除的定时器或回调函数。</li></ul></li></ol>`,84),a=[t];function n(s,p,c,g,d,h){return l(),e("div",null,a)}const f=o(i,[["render",n]]);export{b as __pageData,f as default};
